<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <title>TypeScript HTML App</title>
    <link rel="stylesheet" href="css/app.css" type="text/css" />
    <style>
        #editor {
            position: relative;
            height: 400px;
            width: 100%;
            margin: 10px auto;
        }
		.errorHighlight {
			background: yellow;
			position: absolute;
		}
		pre {
			margin: 10px 0;
			background: lightgray;
		}
    </style>
</head>
<body>
    <div id="container">
        <div id="top">
            <div id="top-content">
                <div id="logo">
                    <h1>
                        <a href="http://csokavar.hu/projects/minischeme">/mini-scheme</a>
                    </h1>
                </div>
            </div>
        </div> <!-- top -->

        <div id="main">
            <div id="main-content">
	            <h2>Mini scheme</h2>
	            <button id="btnRun">run</button>
	            <button id="btnBreak">break</button>
	            <button id="btnStop">stop</button>
	            <button id="btnStep">step</button>
	            <button id="btnContinue">continue</button>
                <div id="editor">(let* ((yin
         ((lambda (cc) (display "#\@") cc) (call-with-current-continuation (lambda (c) c))))
       (yang
         ((lambda (cc) (display "#\*") cc) (call-with-current-continuation (lambda (c) c)))))
    (yin yang))</div>
                <div id="output"></div>
                <pre></pre>
                <pre>(define f 
    (lambda (return)
        (return 2)
        3
    )
)
(call-with-current-continuation f)</pre>
            
                <pre id="factorial">(define fact
    (lambda(x)
        (cond
            ((= x 1) 1)
            (else (* x(fact(- x 1))))
        )
    )
)
(fact 5)
(fact 4)
            </pre>
                <pre>(define for-each 
    (lambda (dg lst)
        (cond 
            ((null? lst) ())
            (else 
                (dg (car lst))
                (for-each dg (cdr lst))
            )
        )
        
    )
)
(define y 0)
(for-each (lambda (x) (set! y (+ y x))) '(1 2 3))
(trace 'sum: y)
</pre>
	            <pre> (define for-each 
    (lambda (dg lst)
        (cond 
            ((null? lst) ())
            (else 
                (dg (car lst))
                (for-each dg (cdr lst))))
    ))
(define generate-one-element-at-a-time (lambda (lst)
  (define control-state (lambda (return)
    (for-each 
        (lambda (element)
            (set! return (call-with-current-continuation
                (lambda (resume-here)
                   (set! control-state resume-here)
                   (return element)))))
        lst)
    (return 'you-fell-off-the-end)))
  
  (define generator (lambda()
    (call-with-current-continuation control-state)))
 
  generator))
  
  
(define generate-digit
  (generate-one-element-at-a-time '(0 1 2)))
(trace 
    (generate-digit)
    (generate-digit)
    (generate-digit)
    (generate-digit))
</pre>
	            <pre>(let ((factorial
      (lambda (n)
               (cond 
                    ((= n 1)
                        1 )
                    (else 
                        (* n (factorial (- n 1)))))
            )))
      (factorial 5))
      
     </pre>
	            <pre> (define (zero? n) (= n 0) )
 
 (letrec ( 
    (even?
        (lambda (n)
            (if (zero? n)
                #t
                (odd? (- n 1)))))
    (odd?
        (lambda (n)
            (if (zero? n)
                 #f
                (even? (- n 1))))))
    (even? 88)
)
      
     </pre>
	            <pre>
					(define alma ())
(define flag #t)
(define (f)
    (display 1 "alma" "fa")
    (call-with-current-continuation
        (lambda (x) 
            (set! alma x)
        )
    )
    (display 2)
    (display 3)
    "vege"
)
(f)
(cond 
    (flag
        (set! flag #f)
        (alma)
    )
)

</pre>	  
	            <pre>(define (length lst)
    (cond 
        ((null? lst) 0)
        (else (+ 1 (length (cdr lst)))))
)
(define (add1 n)
    (+ n 1)
)
(define (sub1 n)
    (- n 1)
)
(define (not a)
    (cond 
        (a #f)
        (else #t))
)
(define (and a b c d)
    (andLst (cons a (cons b (cons c (cons d ())))))
)
(define (andLst lst)
    (cond 
        ((null? lst) #t)
        ((not (car lst)) #f)
        (else (andLst (cdr lst)))
    )
)
;_____________________________________________________
;This function tests to see if the next attempted move (try)
;is legal, given the list that has been constructed thus far
;(if any) - legal-pl (LEGAL PLacement list)
;N.B. - this function is an EXACT copy of the one from
;Springer and Friedman
(define legal?
  (lambda (try legal-pl)
    (letrec
        ((good?
          (lambda (new-pl up down)
            (cond
              ((null? new-pl) #t)
              (else (let ((next-pos (car new-pl)))
                      (and
                       (not (= next-pos try))
                       (not (= next-pos up))
                       (not (= next-pos down))
                       (good? (cdr new-pl)
                              (add1 up)
                              (sub1 down)))))))))
      (good? legal-pl (add1 try) (sub1 try)))))
;_____________________________________________________
;This function tests the length of the solution to
;see if we need to continue "cons"ing on more terms
;or not given to the specified board size.
;
;I modified this function so that it could test the
;validity of any solution for a given boardsize.
(define solution?
    (lambda (legal-pl boardsize)
      (= (length legal-pl) boardsize)))
;_____________________________________________________
;I had to modify this function so that it was passed
;the boardsize in its call, but other than that (and
;simply replacing "fresh-start" with boardsize), just
;about no changes were made.  This function simply
;generates a solution.
(define build-solution
  (lambda (legal-pl boardsize)
    (cond
      ((solution? legal-pl boardsize) legal-pl)
      (else (forward boardsize legal-pl boardsize)))))
;_____________________________________________________
;This function dictates how the next solution will be
;chosen, as it is only called when the last solution
;was proven to be legal, and we are ready to try a new
;placement.
;
;I had to modify this function to include the boardsize
;as well, since it invokes "build-solution".
(define forward
  (lambda (try legal-pl boardsize)
    (cond
      ((zero? try) (backtrack legal-pl boardsize))
      ((legal? try legal-pl) (build-solution (cons try legal-pl) boardsize))
      (else (forward (sub1 try) legal-pl boardsize)))))
;_____________________________________________________
;This function is used when the last move is found to
;be unhelpful (although valid) - instead it tries another
;one until it finds a new solution.
;
;Again, I had to modify this function to include boardsize
;since it calls "forward", which has boardsize as a
;parameter due to the "build-solution" call within it
(define backtrack
  (lambda (legal-pl boardsize)
    (cond
      ((null? legal-pl) '())
      (else (forward (sub1 (car legal-pl)) (cdr legal-pl) boardsize)))))
;_____________________________________________________
;This is pretty much the same function as the one in the book
;with just my minor "boardsize" tweaks, since build-solution
;is called.
(define build-all-solutions
  (lambda (boardsize)
    (letrec
        ((loop (lambda (sol)
                 (cond
                   ((null? sol) '())
                   (else (begin 
                        (display sol)
                        (cons sol (loop (backtrack sol boardsize)))))))))
      (loop (build-solution '() boardsize)))))
;_____________________________________________________
;This function I made up entirely myself, and I only
;made it really to satisfy the syntactical limitations
;of the laboratory instructions.  This makes it so that
;the input of "(queens 4)" will return a list of the
;two possible configurations that are valid solutions,
;even though my modifiend functions would return the same
;value by simply inputting "(build-all-solutions 4)".
(define queens
  (lambda (n)
    (build-all-solutions n)))
    
(queens 4)</pre>

            </div> <!-- main-content -->
        </div> <!-- main -->


        <div id="footer">
            <p><a href="http://www.csokavar.hu/">Encsé Művek</a> - 2015</p>
            <p>Kapcsolat: <a href="mailto:encse@csokavar.hu">encse@csokavar.hu</a></p>
        </div>

    </div> <!--container -->

    <script src="lib/requirejs/require.js"></script>
    <script>
        require.config({
            paths: {
                ace: "js/ace"
            }
        });
    </script>
    <script src="js/app.js"></script>
    <script>
		var sicpEditor = new Editor.SicpEditor("editor", "output");
		document.getElementById("btnBreak").onclick = function() { sicpEditor.break(); };
		document.getElementById("btnContinue").onclick = function () { sicpEditor.continue(); };
		document.getElementById("btnRun").onclick = function () { sicpEditor.run(); };
		document.getElementById("btnStep").onclick = function () { sicpEditor.step(); };
		document.getElementById("btnStop").onclick =function () { sicpEditor.stop(); };
    </script>
</body>
</html>
