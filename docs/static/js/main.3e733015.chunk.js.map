{"version":3,"sources":["lang/Sv.ts","lang/Parser.ts","Env.ts","evaluator/BaseEvaluator.ts","evaluator/ApplicationEvaluator.ts","evaluator/BeginEvaluator.ts","evaluator/BreakpointEvaluator.ts","evaluator/CallCCEvaluator.ts","evaluator/CondEvaluator.ts","evaluator/LambdaEvaluator.ts","evaluator/DefineEvaluator.ts","evaluator/IfEvaluator.ts","evaluator/LetEvaluator.ts","evaluator/QuoteEvaluator.ts","evaluator/SelfEvaluator.ts","evaluator/VariableEvaluator.ts","evaluator/AssignmentEvaluator.ts","Interpreter.ts","App.tsx","index.tsx"],"names":["Sv","Object","_Users_encse_projects_mini_scheme_node_modules_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_2__","this","ilineStart","icolStart","ilineEnd","icolEnd","_Users_encse_projects_mini_scheme_node_modules_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_3__","key","value","toString","first","last","SvAtom","_Sv","_Users_encse_projects_mini_scheme_node_modules_babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_0__","_super","_Users_encse_projects_mini_scheme_node_modules_babel_runtime_helpers_esm_createSuper__WEBPACK_IMPORTED_MODULE_1__","apply","arguments","node","SvCons","matches","SvThunk","_Sv2","_super2","cont","val","_this","call","sv","cast","SvBreakpoint","_Sv3","_super3","_val","_env","_this2","_Sv4","_super4","_car","_cdr","_this3","toStringI","toDisplayString","dgDisplay","st","rv","isNil","car","cdr","_len","length","rvs","Array","_key","listFromRvArray","res","Nil","j","SvAny","cons","newCar","newCdr","cddr","cdddr","cddddr","lst","l","SvNumber","_Sv5","_super5","_this4","SvBool","_Sv6","_super6","_this5","isTrue","False","True","f","SvString","_Sv7","_super7","_this6","JSON","stringify","_Sv8","_super8","_this7","SvSymbol","_Sv9","_super9","_this8","Parser","_Users_encse_projects_mini_scheme_node_modules_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__","regexSymbol","regexNumber","regexString","regexWhiteSpace","regexBoolean","regexComment","tokens","itoken","_Users_encse_projects_mini_scheme_node_modules_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__","getTokens","filter","token","kind","TokenKind","WhiteSpace","Comment","lastToken","push","Token","EOF","accept","parseExpression","tokenKind","currentToken","nextToken","Quote","svBody","withSourceInfo","Symbol","BooleanLit","fromBoolean","NumberLit","eval","StringLit","LParen","tokenStart","exprs","RParen","tokenEnd","iline","icol","ch","test","exec","substr","lines","replace","split","StackFrame","_sv","classCallCheck","createClass","getParentStackFrame","Env","envParent","svSymbolProcedure","undefined","parentStackFrame","obj","hasOwnProperty","name","get","set","BaseEvaluator","stepCount","step","evaluators","env","i","evaluate","lastSv","loop","nextExprs","tag","ApplicationEvaluator","evaluator","getOperator","operator","isPrimitiveProcedure","isCompoundProcedure","isContinuation","evaluateArgs","getArguments","args","evalCall","args0","evaluatedArgs","evaluatedArgsLast","evaluatedArg","setCar","setCdr","stackFrameCurrent","getPrimitiveProcedureDelegate","arg","getContinuationFromCapturedContinuation","newEnv","getProcedureEnv","getProcedureSymbol","params","getProcedureParameters","parameter","define","evaluateList","getProcedureBody","expr","isTaggedList","cadr","caddr","cadddr","caddddr","BeginEvaluator","getBeginActions","BreakpointEvaluator","CallCCEvaluator","getLambda","lambda","listFromRvs","createCcProcedure","CondEvaluator","cond","clause","clauses","isCondElseClause","getCondActions","svCond","nextClauses","getCondClauses","LambdaEvaluator","proc","createCompoundProcedure","getLambdaParameters","getLambdaBody","body","DefineEvaluator","getHead","getFunctionName","getValue","svValue","getVariable","IfEvaluator","getIfPredicate","getIfConsequent","getIfAlternative","LetEvaluator","isLet","isLetStar","isLetrec","letEnv","defs","getBody","def","svSymbol","getDefs","setOrDefine","defsT","QuoteEvaluator","SelfEvaluator","VariableEvaluator","AssignmentEvaluator","Interpreter","log","parse","Math","min","max","abs","lengthI","not","and","or","setEvaluators","setStepCount","Toolbar","props","react_default","a","createElement","className","onRun","onClick","onPause","onStop","onStep","onContinue","App_Samples","samples","onSampleSelected","Samples","options","map","sample","text","trim","onChange","event","target","selectedIndex","Logger","output","NewLineText","newText","str","StackTraceViewer","debuggerState","stackFrame","stackFrameIndex","frameElements","_loop","currentStackFrame","getSvSymbolProcedure","getEnvParent","classes","currentStackFrameIndex","onStackFrameSelect","parent","ScopeViewer","getCurrentStackFrame","scopes","getNames","Editor","_samples$currentSampl","_React$useState","React","useState","_React$useState2","slicedToArray","setSamples","_React$useState3","_React$useState4","currentSampleIndex","setCurrentSampleIndex","_React$useState5","logger","_React$useState7","interpreter","_React$useState9","_React$useState10","setDebuggerState","editorRef","useRef","useEffect","_ref","asyncToGenerator","regenerator_default","mark","_callee","results","_i2","_urls","url","response","wrap","_context","prev","next","fetch","sent","t0","t1","abrupt","stop","fetchSamples","then","_editorRef$current","prog","current","editor","clear","evaluateString","ex","console","_editorRef$current2","markers","startRow","endRow","startCol","endCol","type","gotoLine","id","App_Toolbar","index","objectSpread2","lib_default","ref","mode","theme","editorProps","$blockScrolling","showGutter","width","height","App_NewLineText","App_StackTraceViewer","App_ScopeViewer","App","Fragment","href","App_Editor","rootElement","document","getElementById","ReactDOM","render","src_App"],"mappings":"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","file":"static/js/main.3e733015.chunk.js","sourcesContent":["import { Env } from \"../Env\";\r\nimport { Cont } from \"../IEvaluator\";\r\nimport { ISourceInfo } from \"./Parser\";\r\n\r\nexport class Sv implements ISourceInfo {\r\n\r\n    ilineStart: number;\r\n    icolStart: number;\r\n    ilineEnd: number;\r\n    icolEnd: number;\r\n\r\n    public toDisplayString(): string {\r\n        return this.toString();\r\n    }\r\n\r\n    public withSourceInfo(first: ISourceInfo, last: ISourceInfo):Sv {\r\n        this.ilineStart = first.ilineStart;\r\n        this.icolStart = first.icolStart;\r\n        this.ilineEnd = last.ilineEnd;\r\n        this.icolEnd = last.icolEnd;\r\n        return this;\r\n    }\r\n}\r\n\r\nexport class SvAtom extends Sv {\r\n    public static matches(node: Sv) { return !SvCons.matches(node); }\r\n}\r\n\r\nexport class SvThunk extends Sv {\r\n    public constructor(private cont: Cont, private val: Sv) { super(); }\r\n\r\n    public static matches(node: Sv) { return node instanceof SvThunk; }\r\n\r\n    public static cast(sv: Sv): SvThunk {\r\n        if (!SvThunk.matches(sv)) throw \"Breakpoint expected\";\r\n        return <SvThunk>sv;\r\n    }\r\n    public static call(sv: Sv) {\r\n        return SvThunk.cast(sv).cont((<SvThunk>sv).val);\r\n    }\r\n}\r\nexport class SvBreakpoint extends Sv {\r\n    public constructor(public _val: () => Sv, private _env:Env) { super(); }\r\n\r\n    public static matches(node: Sv): node is SvBreakpoint { return node instanceof SvBreakpoint; }\r\n\r\n    public static cast(sv: Sv): SvBreakpoint {\r\n        if (!SvBreakpoint.matches(sv)) throw \"Breakpoint expected\";\r\n        return <SvBreakpoint>sv;\r\n    }\r\n\r\n    public env(): Env {\r\n        return this._env;\r\n    } \r\n    public val(): () => Sv {\r\n        return this._val;\r\n    }\r\n\r\n    public toString(): string {\r\n        return \"T(\" + this._val.toString()+\")\";\r\n    }\r\n\r\n    public toDisplayString(): string {\r\n        return '';\r\n    }\r\n}\r\n\r\nexport class SvCons extends Sv {\r\n    public constructor(private _car: Sv, private _cdr: Sv) { super(); }\r\n\r\n    public static cons(car:Sv, cdr:Sv) { return new SvCons(car, cdr); }\r\n    public static Nil = new SvCons(null, null);\r\n\r\n    public static listFromRvs(...rvs: Sv[]): Sv {\r\n        return SvCons.listFromRvArray(rvs);\r\n    }\r\n\r\n    public static listFromRvArray(rvs: Sv[]) {\r\n        let res = SvCons.Nil;\r\n        for (let j = rvs.length - 1; j >= 0; j--)\r\n            res = new SvCons(rvs[j], res);\r\n        return res;\r\n    }\r\n\r\n    public static matches(node: Sv) {\r\n            return node instanceof SvCons;\r\n    }\r\n\r\n    public static isNil(node: Sv) {\r\n        return node === SvCons.Nil || (SvCons.matches(node) && SvCons.car(node) === null && SvCons.cdr(node) === null);\r\n    }\r\n\r\n    public static val(sv: Sv) {\r\n        return SvAny.cast(sv)._val;\r\n    }\r\n\r\n    public static cast(sv: Sv): SvCons {\r\n        if (!SvCons.matches(sv)) throw \"Cons expected\";\r\n        return <SvCons>sv;\r\n    }\r\n\r\n    public static car(node: Sv) {\r\n        return SvCons.cast(node)._car;\r\n    }\r\n\r\n    public static cdr(node: Sv) {\r\n        return SvCons.cast(node)._cdr;\r\n    }\r\n\r\n    static setCar(cons: Sv, newCar: Sv) {\r\n        SvCons.cast(cons)._car = newCar;\r\n        return cons;\r\n    }\r\n\r\n    static setCdr(cons: Sv, newCdr: Sv) {\r\n        SvCons.cast(cons)._cdr = newCdr;\r\n        return cons;\r\n    }\r\n    public static cadr(node: Sv) {\r\n        return this.car(this.cdr(node));\r\n    }\r\n\r\n    public static cddr(node: Sv) {\r\n        return this.cdr(this.cdr(node));\r\n    }\r\n\r\n    public static caddr(node: Sv) {\r\n        return this.car(this.cddr(node));\r\n    }\r\n\r\n    public static cdddr(node: Sv) {\r\n        return this.cdr(this.cddr(node));\r\n    }\r\n\r\n    public static cddddr(node: Sv) {\r\n        return this.cdr(this.cdddr(node));\r\n    }\r\n\r\n    public static cadddr(node: Sv) {\r\n        return this.car(this.cdddr(node));\r\n    }\r\n    public static caddddr(node: Sv) {\r\n        return this.car(this.cddddr(node));\r\n    }\r\n    public static lengthI(lst: Sv) {\r\n        let l = 0;\r\n        while (!this.isNil(lst)) {\r\n            l++;\r\n            lst = this.cdr(lst);\r\n        }\r\n        return new SvNumber(l);\r\n    }\r\n\r\n    public toDisplayString(): string {\r\n        return this.toStringI(sv => sv.toDisplayString());\r\n    }\r\n\r\n    public toString(): string {\r\n        return this.toStringI(sv => sv.toString());\r\n    }\r\n\r\n    public toStringI(dgDisplay:(sv:Sv)=>string): string {\r\n        let st = '(';\r\n        let first = true;\r\n\r\n        var rv: Sv = this;\r\n        while (!SvCons.isNil(rv)) {\r\n            if (!first)\r\n                st += \" \";\r\n            first = false;\r\n\r\n            if (SvCons.matches(rv)) {\r\n                st += dgDisplay(SvCons.car(rv));\r\n                rv = SvCons.cdr(rv);\r\n                if (SvAtom.matches(rv)) {\r\n                    st += \" . \" + dgDisplay(rv);\r\n                    break;\r\n                }\r\n            } else {\r\n                st += dgDisplay(rv);\r\n                break;\r\n            }\r\n        }\r\n        st += ')';\r\n        return st;\r\n    }\r\n\r\n}\r\n\r\nexport class SvAny extends Sv {\r\n    public constructor(public _val: any) { super(); }\r\n\r\n    public static matches(node: Sv) { return node instanceof SvAny; }\r\n\r\n    public static val(sv: Sv) {\r\n        return SvAny.cast(sv)._val;\r\n    }\r\n\r\n    public static cast(sv: Sv): SvAny {\r\n        if (!SvAny.matches(sv)) throw \"any expected\";\r\n        return <SvAny>sv;\r\n    }\r\n\r\n    public toDisplayString(): string {\r\n        return '';\r\n    }\r\n    public toString(): string {\r\n        return this._val.toString();\r\n    }\r\n}\r\n\r\nexport class SvBool extends Sv {\r\n    public static True = new SvBool(true);\r\n    public static False = new SvBool(false);\r\n    constructor(public _val: boolean) { super(); }\r\n\r\n    public static matches(node: Sv) { return node instanceof SvBool; }\r\n\r\n    public static isTrue(node: Sv) {\r\n        return SvBool.matches(node) && SvBool.val(node);\r\n    }\r\n\r\n    public static isFalse(node: Sv) {\r\n        return SvBool.matches(node) && !SvBool.val(node);\r\n    }\r\n\r\n    public static val(sv: Sv) {\r\n        return SvBool.cast(sv)._val;\r\n    }\r\n\r\n    public static cast(sv: Sv): SvBool {\r\n        if (!SvBool.matches(sv)) throw \"bool expected\";\r\n        return <SvBool>sv;\r\n    }\r\n\r\n    public toDisplayString(): string {\r\n        return this.toString();\r\n    }\r\n\r\n    public toString(): string {\r\n        return this._val ? \"#t\" : \"#f\";\r\n    }\r\n\r\n    static not(car: Sv) {\r\n        return this.isTrue(car) ? SvBool.False : SvBool.True;\r\n    }\r\n\r\n    static and(lst: Sv) {\r\n        while (!SvCons.isNil(lst)) {\r\n            if (!this.isTrue(SvCons.car(lst)))\r\n                return SvBool.False;\r\n\r\n            lst = SvCons.cdr(lst);\r\n        }\r\n\r\n        return SvBool.True;\r\n    }\r\n\r\n    static or(lst: Sv) {\r\n        while (!SvCons.isNil(lst)) {\r\n            if (this.isTrue(SvCons.car(lst)))\r\n                return SvBool.True;\r\n\r\n            lst = SvCons.cdr(lst);\r\n        }\r\n\r\n        return SvBool.False;\r\n    }\r\n\r\n    public static fromBoolean(f: boolean) {\r\n        return f ? SvBool.True : SvBool.False;\r\n    }\r\n}\r\n\r\nexport class SvString extends Sv {\r\n    public constructor(public _val: string) { super(); }\r\n\r\n    public static matches(node: Sv) { return node instanceof SvString; }\r\n\r\n    public static val(sv: Sv) {\r\n        return SvString.cast(sv)._val;\r\n    }\r\n\r\n    public static cast(sv: Sv): SvString {\r\n        if (!SvString.matches(sv)) throw \"string expected\";\r\n        return <SvString>sv;\r\n    }\r\n\r\n    public toDisplayString(): string {\r\n        return this._val;\r\n    }\r\n\r\n    public toString(): string {\r\n        return JSON.stringify(this._val);\r\n    }\r\n}\r\n\r\nexport class SvNumber extends Sv {\r\n    public constructor(public _val: number) { super(); }\r\n\r\n    public static matches(node: Sv) { return node instanceof SvNumber; }\r\n\r\n    public static val(node: Sv) {\r\n        return SvNumber.cast(node)._val;\r\n    }\r\n\r\n    public static cast(sv: Sv): SvNumber {\r\n        if (!SvNumber.matches(sv)) throw \"Number expected\";\r\n        return <SvNumber>sv;\r\n    }\r\n\r\n    public toDisplayString(): string {\r\n        return this.toString();\r\n    }\r\n\r\n\r\n    public toString(): string {\r\n        return \"\" + this._val;\r\n    }\r\n}\r\n\r\nexport class SvSymbol extends Sv {\r\n    public constructor(public _val: string) { super(); }\r\n\r\n    public static matches(node: Sv) { return node instanceof SvSymbol; }\r\n\r\n    public static val(node: Sv) {\r\n        return SvSymbol.cast(node)._val;\r\n    }\r\n\r\n    public static cast(sv: Sv): SvSymbol {\r\n        if (!SvSymbol.matches(sv)) throw \"Symbol expected\";\r\n        return <SvSymbol>sv;\r\n    }\r\n\r\n    public toDisplayString(): string {\r\n        return this.toString();\r\n    }\r\n\r\n    public toString(): string {\r\n        return this._val;\r\n    }\r\n\r\n    \r\n}","import { SvCons, Sv, SvSymbol, SvBool, SvNumber, SvString } from \"./Sv\";\r\n\r\nexport class Parser {\r\n    private regexSymbol = /^[^\\s()',]+/;\r\n    private regexNumber = /^[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?/;\r\n    private regexString = /^\"([^\\\\\\\"]+|\\\\.)*\"/;\r\n    private regexWhiteSpace = /^\\s*/;\r\n    private regexBoolean = /^#t|^#f/;\r\n    private regexComment = /^;.*/;\r\n\r\n    private tokens: Token[];\r\n    private itoken = 0;\r\n\r\n    public parse(st: string): SvCons {\r\n        this.tokens = this.getTokens(st)\r\n            .filter(token => token.kind !== TokenKind.WhiteSpace && token.kind !== TokenKind.Comment);\r\n        var lastToken = this.tokens.length ? this.tokens[this.tokens.length - 1]: null;\r\n        this.tokens.push(lastToken ?\r\n            new Token(TokenKind.EOF, \"\", lastToken.ilineEnd, lastToken.icolEnd + 1) :\r\n            new Token(TokenKind.EOF, \"\", 0,0) );\r\n        this.itoken = 0;\r\n\r\n        var rvs:Sv[] = [];\r\n        while (!this.accept(TokenKind.EOF))\r\n            rvs.push(this.parseExpression());\r\n\r\n        return SvCons.listFromRvArray(rvs);\r\n    }\r\n\r\n    private nextToken() {\r\n        if (this.itoken < this.tokens.length - 1)\r\n            this.itoken++;\r\n    }\r\n\r\n    private currentToken(): Token {\r\n        return this.tokens[this.itoken];\r\n    }\r\n\r\n    private accept(tokenKind: TokenKind) {\r\n        if (this.currentToken().kind === tokenKind) {\r\n\r\n            this.nextToken();\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    private expect(tokenKind: TokenKind) {\r\n        if (this.accept(tokenKind))\r\n            return true;\r\n        else\r\n            throw 'expected ' + tokenKind + ' found ' + this.currentToken().kind;\r\n    }\r\n\r\n    public parseExpression(): Sv {\r\n        var token = this.currentToken();\r\n\r\n        if (this.accept(TokenKind.Quote)) {\r\n            let svBody = this.parseExpression();\r\n            return new SvCons(new SvSymbol(\"quote\"), svBody).withSourceInfo(token, svBody);\r\n        }\r\n        if (this.accept(TokenKind.Symbol))\r\n            return new SvSymbol(token.st).withSourceInfo(token, token);\r\n        if (this.accept(TokenKind.BooleanLit)) \r\n            return SvBool.fromBoolean(token.st === \"#t\").withSourceInfo(token, token);\r\n        if (this.accept(TokenKind.NumberLit))\r\n            return new SvNumber(eval(token.st)).withSourceInfo(token, token);\r\n        if (this.accept(TokenKind.StringLit))\r\n            return new SvString(eval(token.st)).withSourceInfo(token, token);\r\n        if (this.accept(TokenKind.LParen)) {\r\n            let tokenStart = token;\r\n            let exprs:Sv[] = [];\r\n\r\n            while (!this.accept(TokenKind.RParen)) {\r\n\r\n                if (this.accept(TokenKind.EOF))\r\n                    throw \"unexpected end of input\";\r\n\r\n                exprs.push(this.parseExpression());\r\n            }\r\n\r\n            let tokenEnd = this.tokens[this.itoken - 1];\r\n            return SvCons.listFromRvArray(exprs).withSourceInfo(tokenStart, tokenEnd);\r\n        }\r\n\r\n        throw \"invalid token \" + token;\r\n    }\r\n\r\n    private getTokens(st: string): Token[] {\r\n        let tokens: Token[] = [];\r\n        let iline = 0;\r\n        let icol = 0;\r\n        while (st.length > 0) {\r\n            let ch = st[0];\r\n            let token: Token;\r\n\r\n            if (ch === \"(\")\r\n                token = new Token(TokenKind.LParen, ch, iline, icol);\r\n            else if (ch === \")\")\r\n                token = new Token(TokenKind.RParen, ch, iline, icol);\r\n            else if (ch === \"'\")\r\n                token = new Token(TokenKind.Quote, ch, iline, icol);\r\n            else if (this.regexNumber.test(st))\r\n                token = new Token(TokenKind.NumberLit, this.regexNumber.exec(st)[0], iline, icol);\r\n            else if (this.regexString.test(st))\r\n                token = new Token(TokenKind.StringLit, this.regexString.exec(st)[0], iline, icol);\r\n            else if (this.regexBoolean.test(st))\r\n                token = new Token(TokenKind.BooleanLit, this.regexBoolean.exec(st)[0], iline, icol);\r\n            else if (this.regexComment.test(st))\r\n                token = new Token(TokenKind.Comment, this.regexComment.exec(st)[0], iline, icol);\r\n            else if (this.regexSymbol.test(st))\r\n                token = new Token(TokenKind.Symbol, this.regexSymbol.exec(st)[0], iline, icol);\r\n            else if (this.regexWhiteSpace.test(st))\r\n                token = new Token(TokenKind.WhiteSpace, this.regexWhiteSpace.exec(st)[0], iline, icol);\r\n            else\r\n                throw \"invalid token at '\" + st + \"'\";\r\n            tokens.push(token);\r\n\r\n            if (token.st.length === 0)\r\n                throw \"invalid token\";\r\n            st = st.substr(token.st.length);\r\n            iline = token.ilineEnd;\r\n            icol = token.icolEnd;\r\n        }\r\n\r\n        return tokens;\r\n    }\r\n\r\n}\r\n\r\nexport interface ISourceInfo {\r\n    ilineStart:number;\r\n    icolStart:number;\r\n    ilineEnd:number;\r\n    icolEnd:number;\r\n}\r\n\r\nenum TokenKind {\r\n    WhiteSpace,\r\n    BooleanLit,\r\n    LParen,\r\n    RParen,\r\n    Symbol,\r\n    NumberLit,\r\n    Quote,\r\n    StringLit,\r\n    Comment,\r\n    EOF\r\n}\r\n\r\nclass Token implements ISourceInfo {\r\n    public ilineEnd: number;\r\n    public icolEnd: number;\r\n\r\n    constructor(public kind: TokenKind, public st: string,\r\n        public ilineStart: number, public icolStart: number)\r\n    {\r\n        let lines = st.replace(\"\\r\", \"\").split('\\n');\r\n        this.ilineEnd = this.ilineStart + lines.length - 1;\r\n        if (this.ilineStart === this.ilineEnd)\r\n            this.icolEnd = icolStart + lines[0].length;\r\n        else\r\n            this.icolEnd = lines[lines.length-1].length;\r\n    }\r\n}","import { Sv, SvSymbol } from \"./lang/Sv\";\r\n\r\nexport class StackFrame {\r\n    constructor(private _sv: Sv, private _env: Env) {}\r\n    public sv(): Sv { return this._sv; }\r\n    public env(): Env { return this._env; }\r\n    public parent(): StackFrame { return this._env.getParentStackFrame(); }\r\n}\r\n\r\nexport class Env {\r\n    private obj: {[id: string] : Sv} = {};\r\n    private envParent: Env = null;\r\n    private svSymbolProcedure: SvSymbol;\r\n    private parentStackFrame: StackFrame;\r\n\r\n    constructor(envParent: Env, svSymbolProcedure: SvSymbol = null, parentStackFrame: StackFrame = null) {\r\n        this.envParent = envParent;\r\n        this.svSymbolProcedure = svSymbolProcedure;\r\n        this.parentStackFrame = parentStackFrame;\r\n    }\r\n\r\n    public getNames(): string[] {\r\n        const res: string[] = [];\r\n        for (let key in this.obj) {\r\n            if (this.obj.hasOwnProperty(key))\r\n                res.push(key);\r\n        }\r\n        return res;\r\n    }\r\n\r\n    public getEnvParent(): Env {\r\n        return this.envParent;\r\n    }\r\n\r\n    public getSvSymbolProcedure(): SvSymbol{\r\n        return this.svSymbolProcedure;\r\n    }\r\n\r\n    public getParentStackFrame(): StackFrame {\r\n        if (this.parentStackFrame)\r\n            return this.parentStackFrame;\r\n        if (this.envParent)\r\n            return this.envParent.getParentStackFrame();\r\n        return null;\r\n    }\r\n\r\n    public get(name: string):Sv {\r\n        if (name in this.obj)\r\n            return this.obj[name];\r\n        if (this.envParent == null)\r\n            throw \"no binding for \" + name;\r\n        return this.envParent.get(name);\r\n    }\r\n\r\n    public set(name: string, rv: Sv) {\r\n        if (name in this.obj)\r\n            this.obj[name] = rv;\r\n        else if (this.envParent == null)\r\n            throw name + \" is not declared\";\r\n        else\r\n            this.envParent.set(name, rv);\r\n    }\r\n\r\n    public define(name: string, value: Sv) {\r\n        if (name in this.obj)\r\n            throw name + ' is already defined';\r\n        this.obj[name] = value;\r\n    }\r\n\r\n    setOrDefine(name: string, value: Sv) {\r\n        this.obj[name] = value; \r\n    }\r\n}","import { Env } from \"../Env\";\r\nimport { IEvaluator, Cont } from \"../IEvaluator\";\r\nimport { Sv, SvBreakpoint, SvCons, SvThunk, SvSymbol } from \"../lang/Sv\";\r\n\r\nexport default class BaseEvaluator implements IEvaluator {\r\n    private stepCount: number = 1;\r\n    private step:number = 0 ;\r\n    private evaluators: IEvaluator[];\r\n\r\n    public setEvaluators(evaluators: IEvaluator[]) {\r\n        this.evaluators = evaluators;\r\n    }\r\n\r\n    public setStepCount(stepCount: number) {\r\n        this.stepCount = stepCount;\r\n        this.step = 0;\r\n    }\r\n\r\n    public matches(node: Sv): boolean {\r\n        return true;\r\n    }\r\n\r\n    public evaluate(sv: Sv, env: Env, cont: Cont): Sv {\r\n\r\n        for (var i = 0; i < this.evaluators.length;i++) {\r\n            if (this.evaluators[i].matches(sv)) {\r\n                this.step++;\r\n                if (this.step % this.stepCount == 0)\r\n                    return new SvBreakpoint(() => this.evaluators[i].evaluate(sv, env, cont), env).withSourceInfo(sv, sv);\r\n                else\r\n                    return this.evaluators[i].evaluate(sv, env, cont);\r\n\r\n            }\r\n        }\r\n        throw 'cannot evaluate ' + sv.toString();\r\n    }\r\n\r\n    public evaluateList(exprs: Sv, env: Env, cont: Cont): Sv {\r\n\r\n        var lastSv: Sv = SvCons.Nil;\r\n        var loop = (exprs: Sv): Sv => {\r\n            if (SvCons.isNil(exprs))\r\n                return new SvThunk(cont, lastSv);\r\n\r\n            return this.evaluate(SvCons.car(exprs), env, (sv: Sv) => {\r\n                lastSv = sv;\r\n                var nextExprs = SvCons.cdr(exprs);\r\n                return loop(nextExprs);\r\n            });\r\n        };\r\n\r\n        return loop(exprs);\r\n    }\r\n\r\n    public static isTaggedList(node: Sv, tag: string) {\r\n        if (!SvCons.matches(node)) return false;\r\n        var car = SvCons.car(node);\r\n        return SvSymbol.matches(car) && SvSymbol.val(car) === tag;\r\n    }\r\n}","import { StackFrame, Env } from \"../Env\";\r\nimport { IEvaluator, Cont } from \"../IEvaluator\";\r\nimport { Sv, SvCons, SvThunk, SvSymbol, SvAny } from \"../lang/Sv\";\r\nimport BaseEvaluator from \"./BaseEvaluator\";\r\n\r\nexport default class ApplicationEvaluator implements IEvaluator {\r\n\r\n    constructor(private evaluator: BaseEvaluator) { }\r\n    \r\n    public matches(sv: Sv): boolean {\r\n        return SvCons.matches(sv);\r\n    }\r\n\r\n    public static evalCall(operator:Sv, args: Sv, stackFrameCurrent:StackFrame,cont:Cont, evaluator:BaseEvaluator):Sv {\r\n            \r\n        if (this.isPrimitiveProcedure(operator)) {\r\n            return new SvThunk(cont, this.getPrimitiveProcedureDelegate(operator)(args));\r\n        }\r\n        else if (this.isContinuation(operator)) {\r\n            let arg: Sv = SvCons.Nil;\r\n            if (!SvCons.isNil(args)) {\r\n                if (!SvCons.isNil(SvCons.cdr(args)))\r\n                    throw 'too many argument';\r\n                arg = SvCons.car(args);\r\n            }\r\n            return this.getContinuationFromCapturedContinuation(operator)(arg);\r\n        }\r\n        else if(this.isCompoundProcedure(operator)) {\r\n            const newEnv = new Env(this.getProcedureEnv(operator), this.getProcedureSymbol(operator), stackFrameCurrent);\r\n            let params = this.getProcedureParameters(operator);\r\n\r\n            while (!SvCons.isNil(args) || !SvCons.isNil(params)) {\r\n                if (SvCons.isNil(args))\r\n                    throw 'not enough argument';\r\n                if (SvCons.isNil(params))\r\n                    throw 'too many argument';\r\n                const parameter = SvSymbol.val(SvCons.car(params));\r\n                const arg = SvCons.car(args);\r\n                newEnv.define(parameter, arg);\r\n\r\n                params = SvCons.cdr(params);\r\n                args = SvCons.cdr(args);\r\n            }\r\n            return evaluator.evaluateList(this.getProcedureBody(operator), newEnv, cont);\r\n        }\r\n        else\r\n            throw 'undefined procedure' + operator.toString();\r\n    }\r\n        \r\n\r\n        public evaluate(sv: Sv, env: Env, cont: Cont): Sv {\r\n            return this.evaluator.evaluate(ApplicationEvaluator.getOperator(sv), env, (operator: Sv) => {\r\n            \r\n            if (!ApplicationEvaluator.isPrimitiveProcedure(operator) &&\r\n                !ApplicationEvaluator.isCompoundProcedure(operator) &&\r\n                !ApplicationEvaluator.isContinuation(operator))\r\n                throw 'undefined procedure ' + ApplicationEvaluator.getOperator(sv).toString();\r\n\r\n            return this.evaluateArgs(ApplicationEvaluator.getArguments(sv), env,\r\n                args => ApplicationEvaluator.evalCall(operator, args, new StackFrame(sv, env), cont, this.evaluator));\r\n        });\r\n        \r\n    }\r\n\r\n        private static isCompoundProcedure(expr: Sv) {\r\n            return BaseEvaluator.isTaggedList(expr, 'procedure'); \r\n            \r\n        }\r\n        private static isPrimitiveProcedure(expr: Sv) {\r\n            return BaseEvaluator.isTaggedList(expr, 'primitive'); \r\n            \r\n        }\r\n        private static isContinuation(expr: Sv) {\r\n            return BaseEvaluator.isTaggedList(expr, 'captured-continuation'); \r\n            \r\n        }\r\n    private static getContinuationFromCapturedContinuation(expr: Sv): Cont {\r\n        return SvAny.val(SvCons.cdr(expr)); \r\n    }\r\n\r\n    private static getProcedureSymbol(expr: Sv):SvSymbol { return SvSymbol.cast(SvCons.cadr(expr)); }\r\n    private static getProcedureParameters(expr: Sv) { return SvCons.caddr(expr); }\r\n    private static getProcedureBody(expr: Sv) { return SvCons.cadddr(expr); }\r\n    private static getProcedureEnv(expr: Sv): Env { return SvAny.val(SvCons.caddddr(expr)); }\r\n    private static getPrimitiveProcedureDelegate(expr: Sv) { return SvAny.val(SvCons.cdr(expr)); }\r\n    private static getOperator(expr: Sv) { return SvCons.car(expr); }\r\n    private static getArguments(expr: Sv) { return SvCons.cdr(expr); }\r\n\r\n    evaluateArgs(args0: Sv, env: Env, cont: Cont): Sv {\r\n        const evaluatedArgs = new SvCons(null, null);\r\n        const loop = (evaluatedArgsLast: Sv, args: Sv) :Sv => {\r\n            if (SvCons.isNil(args)) {\r\n                return new SvThunk(cont, evaluatedArgs);\r\n            }\r\n            return this.evaluator.evaluate(SvCons.car(args), env, (evaluatedArg: Sv) => {\r\n                SvCons.setCar(evaluatedArgsLast, evaluatedArg);\r\n                SvCons.setCdr(evaluatedArgsLast, new SvCons(null, null));\r\n                return loop(SvCons.cdr(evaluatedArgsLast), SvCons.cdr(args));\r\n            });\r\n        };\r\n        return loop(evaluatedArgs, args0);\r\n    }\r\n}","import { Env } from \"../Env\";\r\nimport { IEvaluator, Cont } from \"../IEvaluator\";\r\nimport { Sv, SvCons } from \"../lang/Sv\";\r\nimport BaseEvaluator from \"./BaseEvaluator\";\r\n\r\nexport default class BeginEvaluator implements IEvaluator {\r\n    constructor(private evaluator: BaseEvaluator) { }\r\n\r\n    public matches(node: Sv): boolean {\r\n        return BaseEvaluator.isTaggedList(node, 'begin');\r\n    }\r\n\r\n    public evaluate(sv: Sv, env: Env, cont: Cont): Sv {\r\n        return this.evaluator.evaluateList(this.getBeginActions(sv), env, cont);\r\n    }\r\n\r\n    getBeginActions(expr: Sv) { return SvCons.cdr(expr); }\r\n}","import { Env } from \"../Env\";\r\nimport { IEvaluator, Cont } from \"../IEvaluator\";\r\nimport { Sv, SvBreakpoint, SvThunk } from \"../lang/Sv\";\r\nimport BaseEvaluator from \"./BaseEvaluator\";\r\n\r\n    \r\nexport default class BreakpointEvaluator implements IEvaluator {\r\n    \r\n    constructor(private evaluator: BaseEvaluator) { }\r\n    \r\n    public matches(sv: Sv): boolean {\r\n        return SvBreakpoint.matches(sv);\r\n    }\r\n\r\n    public evaluate(sv: Sv, env: Env, cont: Cont): Sv {\r\n        return new SvThunk(cont, SvBreakpoint.cast(sv).val()());\r\n    }\r\n}","import { Env, StackFrame } from \"../Env\";\r\nimport { IEvaluator, Cont } from \"../IEvaluator\";\r\nimport { Sv, SvCons, SvSymbol, SvAny } from \"../lang/Sv\";\r\nimport ApplicationEvaluator from \"./ApplicationEvaluator\";\r\nimport BaseEvaluator from \"./BaseEvaluator\";\r\n\r\nexport default class CallCCEvaluator implements IEvaluator {\r\n\r\n    constructor(private evaluator: BaseEvaluator) { }\r\n    \r\n    public matches(sv: Sv): boolean {\r\n        return BaseEvaluator.isTaggedList(sv, 'call-with-current-continuation');\r\n    }\r\n\r\n    public evaluate(sv: Sv, env: Env, cont: Cont): Sv {\r\n        /* (call-with-current-continuation (lambda (hop) ...)) */\r\n        return this.evaluator.evaluate(this.getLambda(sv), env, lambda => {\r\n            var args = SvCons.listFromRvs(CallCCEvaluator.createCcProcedure(cont));\r\n            return ApplicationEvaluator.evalCall(lambda, args, new StackFrame(sv, env), cont, this.evaluator);\r\n        });\r\n    }\r\n\r\n    getLambda(sv: Sv) { return SvCons.cadr(sv); }\r\n\r\n    private static createCcProcedure(cont: Cont): Sv {\r\n        return new SvCons(new SvSymbol('captured-continuation'), new SvAny(cont));\r\n    }\r\n}","import { Env } from \"../Env\";\r\nimport { IEvaluator, Cont } from \"../IEvaluator\";\r\nimport { Sv, SvCons, SvThunk, SvBool } from \"../lang/Sv\";\r\nimport BaseEvaluator from \"./BaseEvaluator\";\r\n\r\nexport default class CondEvaluator implements IEvaluator {\r\n    constructor(private evaluator: BaseEvaluator) { }\r\n\r\n    public matches(node: Sv): boolean {\r\n        return BaseEvaluator.isTaggedList(node, 'cond');\r\n    }\r\n\r\n    private getCondClauses(cond: Sv) { return SvCons.cdr(cond); }\r\n    private isCondElseClause(clause: Sv) { return BaseEvaluator.isTaggedList(clause, \"else\"); }\r\n    private getCondPredicate(clause: Sv) { return SvCons.car(clause); }\r\n    private getCondActions(clause: Sv) { return SvCons.cdr(clause); }\r\n\r\n    public evaluate(sv: Sv, env: Env, cont: Cont): Sv {\r\n\r\n        var loop = (clauses: Sv): Sv => {\r\n            if (SvCons.isNil(clauses))\r\n                return new SvThunk(cont, clauses);\r\n\r\n            var clause = SvCons.car(clauses);\r\n            if (this.isCondElseClause(clause))\r\n                return this.evaluator.evaluateList(this.getCondActions(clause), env, cont);\r\n\r\n            return this.evaluator.evaluate(SvCons.car(clause), env, (svCond: Sv) => {\r\n                if (SvBool.isTrue(svCond))\r\n                    return this.evaluator.evaluateList(this.getCondActions(clause), env, cont);\r\n                else {\r\n                    var nextClauses = SvCons.cdr(clauses);\r\n                    return loop(nextClauses);\r\n                }\r\n            });\r\n        };\r\n\r\n        var clauses = this.getCondClauses(sv);\r\n        return loop(clauses);\r\n    }\r\n}","import { Env } from \"../Env\";\r\nimport { IEvaluator, Cont } from \"../IEvaluator\";\r\nimport { Sv, SvSymbol, SvThunk, SvCons, SvAny } from \"../lang/Sv\";\r\nimport BaseEvaluator from \"./BaseEvaluator\";\r\n\r\nexport default class LambdaEvaluator implements IEvaluator {\r\n    constructor(private evaluator: BaseEvaluator) {  }\r\n\r\n    public matches(node: Sv): boolean {\r\n        return BaseEvaluator.isTaggedList(node, 'lambda');\r\n    }\r\n\r\n    public evaluate(sv: Sv, env: Env, cont: Cont): Sv {\r\n        var proc = LambdaEvaluator.createCompoundProcedure(\r\n            new SvSymbol(\"lambda\"),\r\n            LambdaEvaluator.getLambdaParameters(sv),\r\n            LambdaEvaluator.getLambdaBody(sv),\r\n            env);\r\n        return new SvThunk(cont, proc);\r\n    }\r\n\r\n    public static createCompoundProcedure(name:SvSymbol, params: Sv, body: Sv, env: Env):Sv {\r\n        return SvCons.listFromRvs(\r\n            new SvSymbol('procedure'),\r\n            name,\r\n            params,\r\n            body,\r\n            new SvAny(env));\r\n    }\r\n    public static getLambdaParameters(expr: Sv) { return SvCons.cadr(expr); }\r\n    public static getLambdaBody(expr: Sv) { return SvCons.cddr(expr); }\r\n\r\n}","import { Env } from \"../Env\";\r\nimport { IEvaluator, Cont } from \"../IEvaluator\";\r\nimport { Sv, SvCons, SvSymbol, SvThunk } from \"../lang/Sv\";\r\nimport BaseEvaluator from \"./BaseEvaluator\";\r\nimport LambdaEvaluator from \"./LambdaEvaluator\";\r\n\r\nexport default class DefineEvaluator implements IEvaluator {\r\n    constructor(private evaluator: BaseEvaluator) {  }\r\n\r\n    public matches(node: Sv): boolean {\r\n        return BaseEvaluator.isTaggedList(node, 'define');\r\n    }\r\n\r\n    public evaluate(sv: Sv, env: Env, cont: Cont): Sv {\r\n\r\n        if (SvCons.matches(this.getHead(sv))) {\r\n            //implicit lambda definition\r\n            var lambda = LambdaEvaluator.createCompoundProcedure(<SvSymbol>this.getFunctionName(sv), this.getLambdaParameters(sv), this.getLambdaBody(sv), env);\r\n            env.define(\r\n                SvSymbol.val(this.getFunctionName(sv)),\r\n                lambda);\r\n            return new SvThunk(cont, lambda);\r\n        }\r\n        else {\r\n            return this.evaluator.evaluate(this.getValue(sv), env, (svValue: Sv):Sv => {\r\n                env.define(\r\n                    SvSymbol.val(this.getVariable(sv)),\r\n                    svValue);\r\n                return new SvThunk(cont, svValue);\r\n            });\r\n        }\r\n    }\r\n\r\n    getHead(sv: Sv): Sv { return SvCons.cadr(sv); }\r\n    getVariable(sv: Sv): Sv { return this.getHead(sv); }\r\n    getValue(sv: Sv): Sv { return SvCons.caddr(sv); }\r\n\r\n    getFunctionName(sv: Sv): Sv { return SvCons.car(this.getHead(sv)); }\r\n    getLambdaParameters(sv: Sv) { return SvCons.cdr(this.getHead(sv)); }\r\n    getLambdaBody(sv: Sv) { return SvCons.cddr(sv); }\r\n}","import { Env } from \"../Env\";\r\nimport { IEvaluator, Cont } from \"../IEvaluator\";\r\nimport { Sv, SvBool, SvCons } from \"../lang/Sv\";\r\nimport BaseEvaluator from \"./BaseEvaluator\";\r\n\r\nexport default class IfEvaluator implements IEvaluator {\r\n    constructor(private evaluator: BaseEvaluator) {  }\r\n\r\n    public matches(node: Sv): boolean {\r\n        return BaseEvaluator.isTaggedList(node, 'if');\r\n    }\r\n\r\n    public evaluate(sv: Sv, env: Env, cont: Cont): Sv {\r\n        return this.evaluator.evaluate(this.getIfPredicate(sv), env, (svCond: Sv) => {\r\n            return SvBool.isTrue(svCond) ?\r\n                this.evaluator.evaluate(this.getIfConsequent(sv), env, cont):\r\n                this.evaluator.evaluate(this.getIfAlternative(sv), env, cont);\r\n        });\r\n    }\r\n\r\n    getIfPredicate(expr: any) { return SvCons.cadr(expr); }\r\n    getIfConsequent(expr: any) { return SvCons.caddr(expr); }\r\n    getIfAlternative(expr: any) { return !SvCons.isNil(SvCons.cdddr(expr)) ? SvCons.cadddr(expr) : SvCons.Nil; }\r\n\r\n}","import { Env } from \"../Env\";\r\nimport { IEvaluator, Cont } from \"../IEvaluator\";\r\nimport { Sv, SvCons, SvSymbol } from \"../lang/Sv\";\r\nimport BaseEvaluator from \"./BaseEvaluator\";\r\n\r\nexport default class LetEvaluator implements IEvaluator {\r\n    constructor(private evaluator: BaseEvaluator) { }\r\n\r\n    public matches(node: Sv): boolean {\r\n        return LetEvaluator.isLet(node) || LetEvaluator.isLetStar(node) || LetEvaluator.isLetrec(node);\r\n    }\r\n\r\n    public evaluate(sv: Sv, env: Env, cont: Cont): Sv {\r\n\r\n        if (LetEvaluator.isLet(sv)) {\r\n            const loop = (letEnv: Env, defs: Sv): Sv => {\r\n                if (SvCons.isNil(defs)) \r\n                    return this.evaluator.evaluateList(LetEvaluator.getBody(sv), letEnv, cont);\r\n                \r\n                const def = SvCons.car(defs);\r\n                const svSymbol = SvCons.car(def);\r\n                return this.evaluator.evaluate(SvCons.cadr(def), env, (svValue) => {\r\n                    letEnv.define(SvSymbol.val(svSymbol), svValue);\r\n                    return loop(letEnv, SvCons.cdr(defs));\r\n                });\r\n            };\r\n            return loop(new Env(env), LetEvaluator.getDefs(sv));\r\n\r\n        }\r\n        else if (LetEvaluator.isLetStar(sv)) {\r\n            const loop = (letEnv:Env, defs: Sv): Sv => {\r\n                if (SvCons.isNil(defs)) \r\n                    return this.evaluator.evaluateList(LetEvaluator.getBody(sv), letEnv, cont);\r\n                \r\n                const def = SvCons.car(defs);\r\n                const svSymbol = SvCons.car(def);\r\n                return this.evaluator.evaluate(SvCons.cadr(def), letEnv, (svValue) => {\r\n                    letEnv = new Env(letEnv);\r\n                    letEnv.setOrDefine(SvSymbol.val(svSymbol), svValue);\r\n                    return loop(letEnv, SvCons.cdr(defs));\r\n                });\r\n            };\r\n            return loop(env, LetEvaluator.getDefs(sv));\r\n        }\r\n        else if (LetEvaluator.isLetrec(sv)) {\r\n            const newEnv = new Env(env); \r\n            let defsT = LetEvaluator.getDefs(sv);\r\n            while (!SvCons.isNil(defsT)) {\r\n                const def = SvCons.car(defsT);\r\n                newEnv.define(SvSymbol.val(SvCons.car(def)), SvCons.Nil);\r\n                defsT = SvCons.cdr(defsT);\r\n            }\r\n\r\n            const loop = (letEnv: Env, defs: Sv): Sv => {\r\n                if (SvCons.isNil(defs))\r\n                    return this.evaluator.evaluateList(LetEvaluator.getBody(sv), letEnv, cont);\r\n                \r\n                const def = SvCons.car(defs);\r\n                const svSymbol = SvCons.car(def);\r\n                return this.evaluator.evaluate(SvCons.cadr(def), letEnv, (svValue) => {\r\n                    letEnv.set(SvSymbol.val(svSymbol), svValue);\r\n                    return loop(letEnv, SvCons.cdr(defs));\r\n                });\r\n            };\r\n\r\n            return loop(newEnv, LetEvaluator.getDefs(sv));\r\n        }\r\n        else\r\n            throw 'uknown let kind';\r\n\r\n        \r\n    }\r\n\r\n    static isLet(node: Sv): boolean { return BaseEvaluator.isTaggedList(node, 'let'); }\r\n    static isLetStar(node: Sv): boolean { return BaseEvaluator.isTaggedList(node, 'let*'); }\r\n    static isLetrec(node: Sv): boolean { return BaseEvaluator.isTaggedList(node, 'letrec'); }\r\n\r\n    static getDefs(sv: Sv) {\r\n        return SvCons.cadr(sv);\r\n    }\r\n\r\n    static getBody(sv: Sv): Sv { return SvCons.cddr(sv); }\r\n}","import { Env } from \"../Env\";\r\nimport { IEvaluator, Cont } from \"../IEvaluator\";\r\nimport { Sv, SvCons, SvThunk } from \"../lang/Sv\";\r\nimport BaseEvaluator from \"./BaseEvaluator\";\r\n\r\nexport default class QuoteEvaluator implements IEvaluator {\r\n    constructor(private evaluator: BaseEvaluator) { }\r\n    public matches(node: Sv): boolean {\r\n        return BaseEvaluator.isTaggedList(node, 'quote');\r\n    }\r\n\r\n    public evaluate(sv: Sv, env: Env, cont: Cont): Sv {\r\n        var res = SvCons.cdr(sv);\r\n        return new SvThunk(cont, res);\r\n    }\r\n}","import { Env } from \"../Env\";\r\nimport { IEvaluator, Cont } from \"../IEvaluator\";\r\nimport { Sv, SvString, SvBool, SvNumber, SvCons, SvThunk } from \"../lang/Sv\";\r\n\r\nexport default class SelfEvaluator implements IEvaluator {\r\n    public matches(node: Sv): boolean {\r\n        return SvString.matches(node) || SvBool.matches(node) ||\r\n            SvNumber.matches(node) || SvCons.isNil(node);\r\n    }\r\n\r\n    public evaluate(sv: Sv, env: Env, cont: Cont): Sv {\r\n        return new SvThunk(cont, sv);\r\n    }\r\n}","import { Env } from \"../Env\";\r\nimport { IEvaluator, Cont } from \"../IEvaluator\";\r\nimport { Sv, SvSymbol, SvThunk } from \"../lang/Sv\";\r\n\r\nexport default class VariableEvaluator implements IEvaluator {\r\n    public matches(node: Sv): boolean {\r\n        return SvSymbol.matches(node);\r\n    }\r\n\r\n    public evaluate(sv: Sv, env: Env, cont: Cont): Sv {\r\n        var res = env.get(SvSymbol.val(sv));\r\n        return new SvThunk(cont, res);\r\n    }\r\n}","import { Env } from \"../Env\";\r\nimport { IEvaluator, Cont } from \"../IEvaluator\";\r\nimport { Sv, SvSymbol, SvThunk, SvCons } from \"../lang/Sv\";\r\nimport BaseEvaluator from \"./BaseEvaluator\";\r\n\r\nexport default class AssignmentEvaluator implements IEvaluator {\r\n    constructor(private evaluator: BaseEvaluator) {  }\r\n\r\n    public matches(sv: Sv): boolean {\r\n        return BaseEvaluator.isTaggedList(sv, 'set!');\r\n    }\r\n\r\n    public evaluate(sv: Sv, env: Env, cont: Cont): Sv {\r\n\r\n        return this.evaluator.evaluate(this.getValue(sv), env, (svValue) => {\r\n            env.set(\r\n                SvSymbol.val(this.getVariable(sv)),\r\n                svValue);\r\n            return new SvThunk(cont, svValue);\r\n        });\r\n    }\r\n\r\n    getVariable(node: Sv): Sv { return SvCons.cadr(node); }\r\n    getValue(node: Sv): Sv { return SvCons.caddr(node); }\r\n}","import { Env } from \"./Env\";\r\nimport { Parser } from \"./lang/Parser\";\r\nimport { SvCons, SvSymbol, SvAny, SvBool, SvNumber, Sv, SvBreakpoint, SvThunk } from \"./lang/Sv\";\r\nimport BaseEvaluator from \"./evaluator/BaseEvaluator\";\r\nimport ApplicationEvaluator from \"./evaluator/ApplicationEvaluator\";\r\nimport BeginEvaluator from \"./evaluator/BeginEvaluator\";\r\nimport BreakpointEvaluator from \"./evaluator/BreakpointEvaluator\";\r\nimport CallCCEvaluator from \"./evaluator/CallCCEvaluator\";\r\nimport CondEvaluator from \"./evaluator/CondEvaluator\";\r\nimport DefineEvaluator from \"./evaluator/DefineEvaluator\";\r\nimport IfEvaluator from \"./evaluator/IfEvaluator\";\r\nimport LambdaEvaluator from \"./evaluator/LambdaEvaluator\";\r\nimport LetEvaluator from \"./evaluator/LetEvaluator\";\r\nimport QuoteEvaluator from \"./evaluator/QuoteEvaluator\";\r\nimport SelfEvaluator from \"./evaluator/SelfEvaluator\";\r\nimport VariableEvaluator from \"./evaluator/VariableEvaluator\";\r\nimport AssignmentEvaluator from \"./evaluator/AssignmentEvaluator\";\r\n\r\nexport class Interpreter {\r\n\r\n    private evaluator: BaseEvaluator;\r\n\r\n    public evaluateString(st: string, log: (st: string) => void) {\r\n        let parser = new Parser();\r\n        let exprs = parser.parse(st);\r\n        let env = new Env(null);\r\n        env.define('cons', new SvCons(new SvSymbol('primitive'), new SvAny((args: any) => new SvCons(SvCons.car(args), SvCons.cadr(args)))));\r\n        env.define('null?', new SvCons(new SvSymbol('primitive'), new SvAny((args: any) => SvBool.fromBoolean(SvCons.isNil(SvCons.car(args))))));\r\n        env.define('car', new SvCons(new SvSymbol('primitive'), new SvAny((args: any) => SvCons.car(SvCons.car(args)))));\r\n        env.define('cadr', new SvCons(new SvSymbol('primitive'), new SvAny((args: any) => SvCons.cadr(SvCons.car(args)))));\r\n        env.define('cdr', new SvCons(new SvSymbol('primitive'), new SvAny((args: any) => SvCons.cdr(SvCons.car(args)))));\r\n        env.define('=', new SvCons(new SvSymbol('primitive'), new SvAny((args: any) => SvBool.fromBoolean(SvNumber.val(SvCons.car(args)) === SvNumber.val(SvCons.cadr(args))))));\r\n        env.define('>', new SvCons(new SvSymbol('primitive'), new SvAny((args: any) => SvBool.fromBoolean(SvNumber.val(SvCons.car(args)) > SvNumber.val(SvCons.cadr(args))))));\r\n        env.define('<', new SvCons(new SvSymbol('primitive'), new SvAny((args: any) => SvBool.fromBoolean(SvNumber.val(SvCons.car(args)) < SvNumber.val(SvCons.cadr(args))))));\r\n        env.define('*', new SvCons(new SvSymbol('primitive'), new SvAny((args: any) => new SvNumber(SvNumber.val(SvCons.car(args)) * SvNumber.val(SvCons.cadr(args))))));\r\n        env.define('-', new SvCons(new SvSymbol('primitive'), new SvAny((args: any) => new SvNumber(SvNumber.val(SvCons.car(args)) - SvNumber.val(SvCons.cadr(args))))));\r\n        env.define('+', new SvCons(new SvSymbol('primitive'), new SvAny((args: any) => new SvNumber(SvNumber.val(SvCons.car(args)) + SvNumber.val(SvCons.cadr(args))))));\r\n        env.define('/', new SvCons(new SvSymbol('primitive'), new SvAny((args: any) => new SvNumber(SvNumber.val(SvCons.car(args)) / SvNumber.val(SvCons.cadr(args))))));\r\n        env.define('min', new SvCons(new SvSymbol('primitive'), new SvAny((args: any) => new SvNumber(Math.min(SvNumber.val(SvCons.car(args)), SvNumber.val(SvCons.cadr(args)))))));\r\n        env.define('max', new SvCons(new SvSymbol('primitive'), new SvAny((args: any) => new SvNumber(Math.max(SvNumber.val(SvCons.car(args)), SvNumber.val(SvCons.cadr(args)))))));\r\n        env.define('abs', new SvCons(new SvSymbol('primitive'), new SvAny((args: any) => new SvNumber(Math.abs(SvNumber.val(SvCons.car(args)))))));\r\n        env.define('zero?', new SvCons(new SvSymbol('primitive'), new SvAny((args: any) => SvBool.fromBoolean(SvNumber.val(SvCons.car(args)) === 0))));\r\n        env.define('length', new SvCons(new SvSymbol('primitive'), new SvAny((args: any) => SvCons.lengthI(SvCons.car(args)))));\r\n        env.define('not', new SvCons(new SvSymbol('primitive'), new SvAny((args: any) => SvBool.not(SvCons.car(args)))));\r\n        env.define('and', new SvCons(new SvSymbol('primitive'), new SvAny((args: any) => SvBool.and(args))));\r\n        env.define('or', new SvCons(new SvSymbol('primitive'), new SvAny((args: any) => SvBool.or(args))));\r\n        env.define('display', new SvCons(new SvSymbol('primitive'), new SvAny((args: any) => {\r\n            while (!SvCons.isNil(args)) {\r\n                log(SvCons.car(args).toDisplayString());\r\n                args = SvCons.cdr(args);\r\n            }\r\n            return SvCons.Nil;\r\n        })));\r\n        env.define('newline', new SvCons(new SvSymbol('primitive'), new SvAny((args: any) => {\r\n            log('\\n');\r\n            return SvCons.Nil;\r\n        })));\r\n        this.evaluator = new BaseEvaluator();\r\n        this.evaluator.setEvaluators([\r\n            new BreakpointEvaluator(this.evaluator),\r\n            new SelfEvaluator(),\r\n            new VariableEvaluator(),\r\n            new LetEvaluator(this.evaluator),\r\n            new QuoteEvaluator(this.evaluator),\r\n            new CondEvaluator(this.evaluator),\r\n            new DefineEvaluator(this.evaluator),\r\n            new AssignmentEvaluator(this.evaluator),\r\n            new IfEvaluator(this.evaluator),\r\n            new BeginEvaluator(this.evaluator),\r\n            new LambdaEvaluator(this.evaluator),\r\n            new CallCCEvaluator(this.evaluator),\r\n            new ApplicationEvaluator(this.evaluator)\r\n        ]);\r\n\r\n        return this.evaluator.evaluateList(exprs, new Env(env), sv => {\r\n            //log(sv.toString());\r\n            return sv;\r\n        });\r\n    }\r\n\r\n    public step(sv: Sv, stepCount: number): Sv {\r\n    \r\n        this.evaluator.setStepCount(stepCount);\r\n\r\n        if (SvBreakpoint.matches(sv)) {\r\n            sv = SvBreakpoint.cast(sv).val()();\r\n            while (SvThunk.matches(sv))\r\n                sv = SvThunk.call(sv);\r\n        }\r\n    \r\n        return SvBreakpoint.matches(sv) ? sv : null;\r\n    }\r\n\r\n}","import React from 'react';\nimport AceEditor from \"react-ace\";\n\nimport \"./App.css\";\nimport \"brace/mode/typescript\";\nimport \"brace/theme/tomorrow_night\";\nimport { Interpreter } from './Interpreter';\nimport { Sv, SvBreakpoint } from './lang/Sv';\nimport { IMarker } from 'react-ace/lib/types';\nimport { StackFrame } from './Env';\n\ntype SampleProps = {\n    samples: string[],\n    onSampleSelected: (index: number) => void;\n}\n\ntype ToolbarProps = SampleProps & {\n    onRun?: () => void;\n    onPause?: () => void;\n    onStop?: () => void;\n    onStep?: () => void;\n    onContinue?: () => void;\n}\n\nconst Toolbar = (props: ToolbarProps) => {\n    return <div className=\"sicp-editor-toolbar\">\n        {props.onRun && <button className=\"sicp-editor-button\" onClick={props.onRun}>run</button>}\n        {props.onPause && <button className=\"sicp-editor-button\" onClick={props.onPause}>pause</button>}\n        {props.onStop && <button className=\"sicp-editor-button\" onClick={props.onStop}>stop</button>}\n        {props.onStep && <button className=\"sicp-editor-button\" onClick={props.onStep}>step</button>}\n        {props.onContinue && <button className=\"sicp-editor-button\" onClick={props.onContinue}>continue</button>}\n        <Samples samples={props.samples} onSampleSelected={props.onSampleSelected} />\n    </div>\n}\n\nconst Samples: React.FC<SampleProps> = (props: SampleProps) => {\n\n    const options = props.samples.map(sample => {\n        let text = sample.split('\\n')[0].trim().replace(/^; /, '');\n        return <option key={sample}>{text}</option>\n    });\n\n    const onChange: React.ChangeEventHandler<HTMLSelectElement> = (event) => {\n        props.onSampleSelected(event.target.selectedIndex);\n    };\n    return <select\n        className=\"sicp-editor-select-sample\"\n        onChange={onChange}>\n        {options}\n    </select>\n}\n\ntype DebuggerState = {\n    kind: \"stopped\"\n} | {\n    kind: \"running\" | \"step\",\n    sv: Sv\n} | {\n    kind: \"paused\",\n    sv: SvBreakpoint,\n    currentStackFrameIndex: number\n};\n\n\nfunction getCurrentStackFrame(debuggerState: DebuggerState): StackFrame {\n    if (debuggerState.kind !== \"paused\") {\n        return null;\n    }\n\n    let stackFrame = new StackFrame(debuggerState.sv, debuggerState.sv.env());\n    for (let i = 0; stackFrame && i < debuggerState.currentStackFrameIndex; i++) {\n        stackFrame = stackFrame.parent();\n    }\n    return stackFrame;\n}\n\nclass Logger {\n    output: string;\n    clear() {\n        this.output = \"\";\n    }\n    log = (st: string) => {\n        this.output += st;\n    }\n}\n\ntype NewLineTextProps = {\n    text: string\n}\n\nconst NewLineText: React.FC<NewLineTextProps> = (props) => {\n    if(!props.text) {\n        return <div/>;\n    }\n\n    const text = props.text;\n    const newText = text.split('\\n').map(str => <div>{str}</div>);\n    return <div>{newText}</div>;\n}\n\ntype StackTraceViewerProps = {\n    debuggerState: DebuggerState,\n    onStackFrameSelect: (i: number) => void\n}\n\nconst StackTraceViewer: React.FC<StackTraceViewerProps> = (props) => {\n    const debuggerState = props.debuggerState;\n    if (debuggerState.kind != \"paused\" || !SvBreakpoint.matches(debuggerState.sv)) {\n        return <div />\n    }\n\n    const sv = debuggerState.sv;\n    let stackFrame = new StackFrame(sv, sv.env());\n    let stackFrameIndex = 0;\n    let frameElements: React.ReactElement[] = [];\n    while (stackFrame) {\n        const currentStackFrame = stackFrameIndex;\n        let env = stackFrame.env();\n        while (env != null && env.getSvSymbolProcedure() == null)\n            env = env.getEnvParent();\n\n        const classes = 'sicp-stack-frame ' + ((currentStackFrame == debuggerState.currentStackFrameIndex) ? 'sicp-stack-frame-current' : '');\n        frameElements.push(\n            <div className={classes} key={stackFrameIndex} onClick={() => props.onStackFrameSelect(currentStackFrame)}>\n                <p>{!env ? \"« not in procedure »\" : env.getSvSymbolProcedure().toString()}</p>\n            </div>\n        );\n        stackFrame = stackFrame.parent();\n        stackFrameIndex++;\n    }\n\n    return <div>{frameElements}</div>;\n}\n\ntype ScopeViewerProps = {\n    debuggerState: DebuggerState,\n}\n\nconst ScopeViewer: React.FC<ScopeViewerProps> = (props) => {\n\n    const debuggerState = props.debuggerState;\n    let stackFrame = getCurrentStackFrame(debuggerState)\n    if (stackFrame == null) {\n        return <div />;\n    }\n\n    let env = stackFrame.env();\n    let scopes: React.ReactElement[] = [];\n    while (env) {\n        //                 $(pTitle).click(() => { $(divScope).toggleClass('sicp-tree-node-collapsed'); });\n\n        scopes.push(<div>\n            <p className=\"sicp-tree-node-title\">Scope</p>\n            {env.getNames().length > 0 &&\n                <div className=\"sicp-tree-node-content\">\n                    {\n                        env.getNames().map(name =>\n                            <div key={name}>\n                                <div className=\"sicp-variable-name\">{name}</div>\n                                <div className=\"sicp-variable-value\">{env.get(name).toString()}</div>\n                            </div>\n                        )\n                    }\n                </div>\n            }\n            {env.getNames().length === 0 && <p className=\"sicp-scope-empty\">« empty »</p>}\n        </div>\n        );\n        env = env.getEnvParent();\n    }\n    return <div>{scopes}</div>\n}\n\nconst Editor = () => {\n    const [samples, setSamples] = React.useState<string[]>([]);\n    const [currentSampleIndex, setCurrentSampleIndex] = React.useState<number>(0);\n    const [logger] = React.useState<Logger>(new Logger);\n    const [interpreter] = React.useState<Interpreter>(new Interpreter());\n    const [debuggerState, setDebuggerState] = React.useState<DebuggerState>({ kind: \"stopped\" });\n    const editorRef = React.useRef<AceEditor>();\n    React.useEffect(() => {\n        const fetchSamples = async () => {\n            const urls = [\n                'samples/factorial.ms',\n                'samples/odd-or-even.ms',\n                'samples/counting-change.ms',\n                'samples/hanoi.ms',\n                'samples/n-queens.ms',\n                'samples/return-with-callcc.ms',\n                'samples/lazy-generator.ms',\n                'samples/yin-yang.ms'\n            ];\n\n            const results: string[] = [];\n            for (let url of urls) {\n                const response = await fetch(url);\n                results.push(await response.text());\n            }\n            return results;\n        }\n        fetchSamples().then(setSamples);\n    }, []);\n\n    React.useEffect(() => {\n        if (debuggerState.kind == \"running\" || debuggerState.kind === \"step\") {\n            try {\n                let sv = debuggerState.sv;\n                if (sv == null) {\n                    const prog: string = editorRef.current?.editor.getValue();\n                    if (prog) {\n                        stop();\n                        logger.clear();\n                        sv = interpreter.evaluateString(prog, logger.log);\n                    }\n                } else {\n                    sv = interpreter.step(debuggerState.sv, debuggerState.kind == \"running\" ? 10000 : 1);\n                }\n\n                if (sv == null) {\n                    setDebuggerState({ kind: \"stopped\" });\n                } else if (debuggerState.kind == \"running\") {\n                    setDebuggerState({ kind: \"running\", sv });\n                } else if (SvBreakpoint.matches(sv)) {\n                    setDebuggerState({ kind: \"paused\", sv, currentStackFrameIndex: 0 });\n                } else {\n                    setDebuggerState({ kind: \"stopped\" });\n                }\n            } catch (ex) {\n                console.log(ex);\n                logger.log(\"\\nan error occured\");\n                setDebuggerState({ kind: \"stopped\" });\n            }\n        }\n    }, [debuggerState]);\n\n    const setSampleIndex = (index: number) => {\n        stop();\n        setCurrentSampleIndex(index);\n    };\n\n    const run = () => {\n        setDebuggerState({ kind: \"running\", sv: null });\n    }\n\n    const stop = () => {\n        setDebuggerState({ kind: \"stopped\" });\n    };\n\n    const step = () => {\n        if (debuggerState.kind == \"paused\") {\n            setDebuggerState({ ...debuggerState, kind: \"step\" });\n        } else if (debuggerState.kind == \"stopped\") {\n            setDebuggerState({ kind: \"step\", sv: null });\n        }\n    };\n\n    const cont = () => {\n        if (debuggerState.kind == \"paused\") {\n            setDebuggerState({ ...debuggerState, kind: \"running\" });\n        }\n    };\n\n    const pause = () => {\n        if (debuggerState.kind == \"running\" && SvBreakpoint.matches(debuggerState.sv)) {\n            setDebuggerState({\n                kind: \"paused\",\n                sv: debuggerState.sv, \n                currentStackFrameIndex: 0 \n            });\n        }\n    };\n\n    const setStackFrameIndex = (index: number) => {\n        if (debuggerState.kind == \"paused\") {\n            setDebuggerState({ ...debuggerState, kind: \"paused\", currentStackFrameIndex: index });\n        }\n    };\n\n    const markers: IMarker[] = [];\n\n    if (debuggerState.kind == \"paused\") {\n        markers.push({\n            startRow: debuggerState.sv.ilineStart,\n            endRow: debuggerState.sv.ilineEnd,\n            startCol: debuggerState.sv.icolStart,\n            endCol: debuggerState.sv.icolEnd,\n            className: \"current-statement\",\n            type: \"text\"\n        })\n        editorRef.current?.editor.gotoLine(debuggerState.sv.ilineStart);\n    }\n\n    return (\n        <div id=\"editor-wrap\">\n            <div id=\"editor\">\n                <Toolbar\n                    samples={samples}\n                    onSampleSelected={setSampleIndex}\n                    onRun={debuggerState.kind == \"stopped\" ? run : null}\n                    onStop={debuggerState.kind == \"paused\" || debuggerState.kind == \"running\" ? stop : null}\n                    onPause={debuggerState.kind == \"running\" ? pause : null}\n                    onStep={debuggerState.kind == \"paused\" || debuggerState.kind == \"stopped\" ? step : null}\n                    onContinue={debuggerState.kind == \"paused\" ? cont : null}\n                />\n                <AceEditor\n                    ref={editorRef}\n                    className=\"editorWindow\"\n                    mode=\"typescript\"\n                    theme=\"tomorrow_night\"\n                    name=\"ace-editor\"\n                    editorProps={{ $blockScrolling: false }}\n                    value={samples[currentSampleIndex] ?? \"\"}\n                    showGutter={true}\n                    width=\"auto\"\n                    height=\"auto\"\n                    markers={markers}\n                />\n            </div>\n            <div id=\"editor-bottom\">\n                <div className=\"sicp-box\">\n                    <p className=\"sicp-box-tab-title\">Output</p>\n                    <div id=\"output-content\" className=\"sicp-box-tab-content\"><NewLineText text={logger.output} /></div>\n                </div>\n                <div className=\"sicp-box\">\n                    <p className=\"sicp-box-tab-title\">Stacktrace</p>\n                    <div id=\"stacktrace-content\" className=\"sicp-box-tab-content\">\n                        <StackTraceViewer debuggerState={debuggerState} onStackFrameSelect={setStackFrameIndex} />\n                    </div>\n                </div>\n                <div className=\"sicp-box\">\n                    <p className=\"sicp-box-tab-title\">Variables</p>\n                    <div id=\"variables-content\" className=\"sicp-box-tab-content\">\n                        <ScopeViewer debuggerState={debuggerState} />\n                    </div>\n                </div>\n            </div>\n        </div>\n    );\n}\n\nfunction App() {\n    return (\n        <>\n            <div id=\"header\">\n                <h2>Mini scheme</h2>\n                <p>by <a href=\"https://csokavar.hu\">encse</a></p>\n            </div>\n            <Editor />\n            <div id=\"footer\">Copyright 2015, source is available on <a href=\"https://github.com/encse/sicp\">GitHub</a></div>\n        </>\n    );\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\n\nconst rootElement = document.getElementById(\"root\");\nReactDOM.render(<App />, rootElement);\n"],"sourceRoot":""}