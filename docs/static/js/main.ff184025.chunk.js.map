{"version":3,"sources":["lang/sv.ts","lang/parser.ts","lang/env.ts","lang/base-evaluator.ts","lang/application-evaluator.ts","lang/begin-evaluator.ts","lang/breakpoint-evaluator.ts","lang/call-cc-evaluator.ts","lang/cond-evaluator.ts","lang/lambda-evaluator.ts","lang/define-evaluator.ts","lang/if-evaluator.ts","lang/let-evaluator.ts","lang/quote-evaluator.ts","lang/self-evaluator.ts","lang/variable-evaluator.ts","lang/assignment-evaluator.ts","lang/interpreter.ts","editor/debugger-state.ts","editor/samples.tsx","editor/toolbar.tsx","editor/scopes.tsx","editor/stacktrace.tsx","editor/logger.ts","editor/new-line-text.tsx","editor/editor.tsx","App.tsx","index.tsx"],"names":["Sv","Object","_Users_encse_projects_mini_scheme_node_modules_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_2__","this","ilineStart","icolStart","ilineEnd","icolEnd","_Users_encse_projects_mini_scheme_node_modules_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_3__","key","value","toString","first","last","SvAtom","_Sv","_Users_encse_projects_mini_scheme_node_modules_babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_0__","_super","_Users_encse_projects_mini_scheme_node_modules_babel_runtime_helpers_esm_createSuper__WEBPACK_IMPORTED_MODULE_1__","apply","arguments","node","SvCons","matches","SvThunk","_Sv2","_super2","cont","val","_this","call","sv","Error","cast","SvBreakpoint","_Sv3","_super3","_val","_env","_this2","_Sv4","_super4","_car","_cdr","_this3","toStringI","toDisplayString","dgDisplay","st","rv","isNil","car","cdr","_len","length","rvs","Array","_key","listFromRvArray","res","Nil","j","SvAny","cons","newCar","newCdr","cddr","cdddr","cddddr","lst","l","SvNumber","_Sv5","_super5","_this4","SvBool","_Sv6","_super6","_this5","isTrue","False","True","f","SvString","_Sv7","_super7","_this6","JSON","stringify","_Sv8","_super8","_this7","SvSymbol","_Sv9","_super9","_this8","TokenKind","Parser","_Users_encse_projects_mini_scheme_node_modules_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__","regexSymbol","regexNumber","regexString","regexWhiteSpace","regexBoolean","regexComment","tokens","itoken","_Users_encse_projects_mini_scheme_node_modules_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__","getTokens","filter","token","kind","WhiteSpace","Comment","lastToken","push","Token","EOF","accept","parseExpression","tokenKind","currentToken","nextToken","Quote","svBody","withSourceInfo","Symbol","BooleanLit","fromBoolean","NumberLit","eval","StringLit","LParen","tokenStart","exprs","RParen","tokenEnd","iline","icol","ch","test","exec","substr","lines","replace","split","StackFrame","_sv","classCallCheck","createClass","getParentStackFrame","Env","envParent","svSymbolProcedure","undefined","parentStackFrame","obj","hasOwnProperty","name","get","set","BaseEvaluator","stepCount","step","evaluators","env","i","evaluate","lastSv","loop","nextExprs","tag","ApplicationEvaluator","evaluator","getOperator","operator","isPrimitiveProcedure","isCompoundProcedure","isContinuation","evaluateArgs","getArguments","args","evalCall","args0","evaluatedArgs","evaluatedArgsLast","evaluatedArg","setCar","setCdr","stackFrameCurrent","getPrimitiveProcedureDelegate","arg","getContinuationFromCapturedContinuation","newEnv","getProcedureEnv","getProcedureSymbol","params","getProcedureParameters","parameter","define","evaluateList","getProcedureBody","expr","isTaggedList","cadr","caddr","cadddr","caddddr","BeginEvaluator","getBeginActions","BreakpointEvaluator","CallCCEvaluator","getLambda","lambda","listFromRvs","createCcProcedure","CondEvaluator","cond","clause","clauses","isCondElseClause","getCondActions","svCond","nextClauses","getCondClauses","LambdaEvaluator","proc","createCompoundProcedure","getLambdaParameters","getLambdaBody","body","DefineEvaluator","getHead","getFunctionName","getValue","svValue","getVariable","IfEvaluator","getIfPredicate","getIfConsequent","getIfAlternative","LetEvaluator","isLet","isLetStar","isLetrec","letEnv","defs","getBody","def","svSymbol","getDefs","setOrDefine","defsT","QuoteEvaluator","SelfEvaluator","VariableEvaluator","AssignmentEvaluator","Interpreter","log","parse","Math","min","max","abs","lengthI","not","and","or","setEvaluators","setStepCount","getCurrentStackFrame","debuggerState","stackFrame","currentStackFrameIndex","parent","Samples","props","options","samples","map","sample","text","trim","react_default","a","createElement","className","onChange","event","onSampleSelected","target","selectedIndex","Toolbar","onRun","onClick","onPause","onStop","onStep","onContinue","samples_Samples","Scopes","scopes","getNames","getEnvParent","Stacktrace","stackFrameIndex","frameElements","_loop","currentStackFrame","getSvSymbolProcedure","classes","onStackFrameSelect","Logger","output","NewLineText","newText","str","Editor","_React$PureComponent","inherits","createSuper","setSampleIndex","index","_this$state$samples$i","stop","setState","program","state","currentSampleIndex","run","objectSpread2","pause","setStackFrameIndex","edit","stepInterpreter","_this$state","interpreter","logger","clear","evaluateString","ex","console","editorRef","React","createRef","_ref","asyncToGenerator","regenerator_default","mark","_callee","_iterator","_step","url","response","wrap","_context","prev","next","createForOfIteratorHelper","sampleUrls","s","n","done","fetch","sent","t0","t1","t2","e","finish","abrupt","fetchSamples","then","_this$state2","setTimeout","_editorRef$current","markers","startRow","endRow","startCol","endCol","type","current","editor","gotoLine","id","toolbar_Toolbar","lib_default","ref","mode","theme","editorProps","$blockScrolling","showGutter","width","height","new_line_text_NewLineText","stacktrace_Stacktrace","scopes_Scopes","PureComponent","App","Fragment","href","editor_Editor","rootElement","document","getElementById","ReactDOM","render","src_App"],"mappings":"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","file":"static/js/main.ff184025.chunk.js","sourcesContent":["import { Env } from \"./env\";\r\nimport { Cont } from \"./ievaluator\";\r\nimport { ISourceInfo } from \"./parser\";\r\n\r\nexport class Sv implements ISourceInfo {\r\n\r\n    ilineStart: number;\r\n    icolStart: number;\r\n    ilineEnd: number;\r\n    icolEnd: number;\r\n\r\n    public toDisplayString(): string {\r\n        return this.toString();\r\n    }\r\n\r\n    public withSourceInfo(first: ISourceInfo, last: ISourceInfo):Sv {\r\n        this.ilineStart = first.ilineStart;\r\n        this.icolStart = first.icolStart;\r\n        this.ilineEnd = last.ilineEnd;\r\n        this.icolEnd = last.icolEnd;\r\n        return this;\r\n    }\r\n}\r\n\r\nexport class SvAtom extends Sv {\r\n    public static matches(node: Sv) { return !SvCons.matches(node); }\r\n}\r\n\r\nexport class SvThunk extends Sv {\r\n    public constructor(private cont: Cont, private val: Sv) { super(); }\r\n\r\n    public static matches(node: Sv) { return node instanceof SvThunk; }\r\n\r\n    public static cast(sv: Sv): SvThunk {\r\n        if (!SvThunk.matches(sv)) throw new Error(\"Breakpoint expected\");\r\n        return sv as SvThunk;\r\n    }\r\n    public static call(sv: Sv) {\r\n        return SvThunk.cast(sv).cont((sv as SvThunk).val);\r\n    }\r\n}\r\nexport class SvBreakpoint extends Sv {\r\n    public constructor(public _val: () => Sv, private _env:Env) { super(); }\r\n\r\n    public static matches(node: Sv): node is SvBreakpoint { return node instanceof SvBreakpoint; }\r\n\r\n    public static cast(sv: Sv): SvBreakpoint {\r\n        if (!SvBreakpoint.matches(sv)) throw new Error(\"Breakpoint expected\");\r\n        return sv as SvBreakpoint;\r\n    }\r\n\r\n    public env(): Env {\r\n        return this._env;\r\n    } \r\n    public val(): () => Sv {\r\n        return this._val;\r\n    }\r\n\r\n    public toString(): string {\r\n        return \"T(\" + this._val.toString()+\")\";\r\n    }\r\n\r\n    public toDisplayString(): string {\r\n        return '';\r\n    }\r\n}\r\n\r\nexport class SvCons extends Sv {\r\n    public constructor(private _car: Sv, private _cdr: Sv) { super(); }\r\n\r\n    public static cons(car:Sv, cdr:Sv) { return new SvCons(car, cdr); }\r\n    public static Nil = new SvCons(null, null);\r\n\r\n    public static listFromRvs(...rvs: Sv[]): Sv {\r\n        return SvCons.listFromRvArray(rvs);\r\n    }\r\n\r\n    public static listFromRvArray(rvs: Sv[]) {\r\n        let res = SvCons.Nil;\r\n        for (let j = rvs.length - 1; j >= 0; j--)\r\n            res = new SvCons(rvs[j], res);\r\n        return res;\r\n    }\r\n\r\n    public static matches(node: Sv) {\r\n            return node instanceof SvCons;\r\n    }\r\n\r\n    public static isNil(node: Sv) {\r\n        return node === SvCons.Nil || (SvCons.matches(node) && SvCons.car(node) === null && SvCons.cdr(node) === null);\r\n    }\r\n\r\n    public static val(sv: Sv) {\r\n        return SvAny.cast(sv)._val;\r\n    }\r\n\r\n    public static cast(sv: Sv): SvCons {\r\n        if (!SvCons.matches(sv)) throw new Error(\"Cons expected\");\r\n        return sv as SvCons;\r\n    }\r\n\r\n    public static car(node: Sv) {\r\n        return SvCons.cast(node)._car;\r\n    }\r\n\r\n    public static cdr(node: Sv) {\r\n        return SvCons.cast(node)._cdr;\r\n    }\r\n\r\n    static setCar(cons: Sv, newCar: Sv) {\r\n        SvCons.cast(cons)._car = newCar;\r\n        return cons;\r\n    }\r\n\r\n    static setCdr(cons: Sv, newCdr: Sv) {\r\n        SvCons.cast(cons)._cdr = newCdr;\r\n        return cons;\r\n    }\r\n    public static cadr(node: Sv) {\r\n        return this.car(this.cdr(node));\r\n    }\r\n\r\n    public static cddr(node: Sv) {\r\n        return this.cdr(this.cdr(node));\r\n    }\r\n\r\n    public static caddr(node: Sv) {\r\n        return this.car(this.cddr(node));\r\n    }\r\n\r\n    public static cdddr(node: Sv) {\r\n        return this.cdr(this.cddr(node));\r\n    }\r\n\r\n    public static cddddr(node: Sv) {\r\n        return this.cdr(this.cdddr(node));\r\n    }\r\n\r\n    public static cadddr(node: Sv) {\r\n        return this.car(this.cdddr(node));\r\n    }\r\n    public static caddddr(node: Sv) {\r\n        return this.car(this.cddddr(node));\r\n    }\r\n    public static lengthI(lst: Sv) {\r\n        let l = 0;\r\n        while (!this.isNil(lst)) {\r\n            l++;\r\n            lst = this.cdr(lst);\r\n        }\r\n        return new SvNumber(l);\r\n    }\r\n\r\n    public toDisplayString(): string {\r\n        return this.toStringI(sv => sv.toDisplayString());\r\n    }\r\n\r\n    public toString(): string {\r\n        return this.toStringI(sv => sv.toString());\r\n    }\r\n\r\n    public toStringI(dgDisplay:(sv:Sv)=>string): string {\r\n        let st = '(';\r\n        let first = true;\r\n\r\n        var rv: Sv = this;\r\n        while (!SvCons.isNil(rv)) {\r\n            if (!first)\r\n                st += \" \";\r\n            first = false;\r\n\r\n            if (SvCons.matches(rv)) {\r\n                st += dgDisplay(SvCons.car(rv));\r\n                rv = SvCons.cdr(rv);\r\n                if (SvAtom.matches(rv)) {\r\n                    st += \" . \" + dgDisplay(rv);\r\n                    break;\r\n                }\r\n            } else {\r\n                st += dgDisplay(rv);\r\n                break;\r\n            }\r\n        }\r\n        st += ')';\r\n        return st;\r\n    }\r\n\r\n}\r\n\r\nexport class SvAny extends Sv {\r\n    public constructor(public _val: any) { super(); }\r\n\r\n    public static matches(node: Sv) { return node instanceof SvAny; }\r\n\r\n    public static val(sv: Sv) {\r\n        return SvAny.cast(sv)._val;\r\n    }\r\n\r\n    public static cast(sv: Sv): SvAny {\r\n        if (!SvAny.matches(sv)) throw new Error(\"any expected\");\r\n        return sv as SvAny;\r\n    }\r\n\r\n    public toDisplayString(): string {\r\n        return '[any]';\r\n    }\r\n    public toString(): string {\r\n        return this._val.toString();\r\n    }\r\n}\r\n\r\nexport class SvBool extends Sv {\r\n    public static True = new SvBool(true);\r\n    public static False = new SvBool(false);\r\n    constructor(public _val: boolean) { super(); }\r\n\r\n    public static matches(node: Sv) { return node instanceof SvBool; }\r\n\r\n    public static isTrue(node: Sv) {\r\n        return SvBool.matches(node) && SvBool.val(node);\r\n    }\r\n\r\n    public static isFalse(node: Sv) {\r\n        return SvBool.matches(node) && !SvBool.val(node);\r\n    }\r\n\r\n    public static val(sv: Sv) {\r\n        return SvBool.cast(sv)._val;\r\n    }\r\n\r\n    public static cast(sv: Sv): SvBool {\r\n        if (!SvBool.matches(sv)) throw new Error(\"bool expected\");\r\n        return sv as SvBool;\r\n    }\r\n\r\n    public toDisplayString(): string {\r\n        return this.toString();\r\n    }\r\n\r\n    public toString(): string {\r\n        return this._val ? \"#t\" : \"#f\";\r\n    }\r\n\r\n    static not(car: Sv) {\r\n        return this.isTrue(car) ? SvBool.False : SvBool.True;\r\n    }\r\n\r\n    static and(lst: Sv) {\r\n        while (!SvCons.isNil(lst)) {\r\n            if (!this.isTrue(SvCons.car(lst)))\r\n                return SvBool.False;\r\n\r\n            lst = SvCons.cdr(lst);\r\n        }\r\n\r\n        return SvBool.True;\r\n    }\r\n\r\n    static or(lst: Sv) {\r\n        while (!SvCons.isNil(lst)) {\r\n            if (this.isTrue(SvCons.car(lst)))\r\n                return SvBool.True;\r\n\r\n            lst = SvCons.cdr(lst);\r\n        }\r\n\r\n        return SvBool.False;\r\n    }\r\n\r\n    public static fromBoolean(f: boolean) {\r\n        return f ? SvBool.True : SvBool.False;\r\n    }\r\n}\r\n\r\nexport class SvString extends Sv {\r\n    public constructor(public _val: string) { super(); }\r\n\r\n    public static matches(node: Sv) { return node instanceof SvString; }\r\n\r\n    public static val(sv: Sv) {\r\n        return SvString.cast(sv)._val;\r\n    }\r\n\r\n    public static cast(sv: Sv): SvString {\r\n        if (!SvString.matches(sv)) throw new Error(\"string expected\");\r\n        return sv as SvString;\r\n    }\r\n\r\n    public toDisplayString(): string {\r\n        return this._val;\r\n    }\r\n\r\n    public toString(): string {\r\n        return JSON.stringify(this._val);\r\n    }\r\n}\r\n\r\nexport class SvNumber extends Sv {\r\n    public constructor(public _val: number) { super(); }\r\n\r\n    public static matches(node: Sv) { return node instanceof SvNumber; }\r\n\r\n    public static val(node: Sv) {\r\n        return SvNumber.cast(node)._val;\r\n    }\r\n\r\n    public static cast(sv: Sv): SvNumber {\r\n        if (!SvNumber.matches(sv)) throw new Error(\"Number expected\");\r\n        return sv as SvNumber;\r\n    }\r\n\r\n    public toDisplayString(): string {\r\n        return this.toString();\r\n    }\r\n\r\n\r\n    public toString(): string {\r\n        return \"\" + this._val;\r\n    }\r\n}\r\n\r\nexport class SvSymbol extends Sv {\r\n    public constructor(public _val: string) { super(); }\r\n\r\n    public static matches(node: Sv) { return node instanceof SvSymbol; }\r\n\r\n    public static val(node: Sv) {\r\n        return SvSymbol.cast(node)._val;\r\n    }\r\n\r\n    public static cast(sv: Sv): SvSymbol {\r\n        if (!SvSymbol.matches(sv)) throw new Error(\"Symbol expected\");\r\n        return sv as SvSymbol;\r\n    }\r\n\r\n    public toDisplayString(): string {\r\n        return this.toString();\r\n    }\r\n\r\n    public toString(): string {\r\n        return this._val;\r\n    }\r\n\r\n    \r\n}","import { SvCons, Sv, SvSymbol, SvBool, SvNumber, SvString } from \"./sv\";\r\n\r\nenum TokenKind {\r\n    WhiteSpace,\r\n    BooleanLit,\r\n    LParen,\r\n    RParen,\r\n    Symbol,\r\n    NumberLit,\r\n    Quote,\r\n    StringLit,\r\n    Comment,\r\n    EOF\r\n}\r\n\r\nexport class Parser {\r\n    private regexSymbol = /^[^\\s()',]+/;\r\n    private regexNumber = /^[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?/;\r\n    private regexString = /^\"([^\\\\\"]+|\\\\.)*\"/;\r\n    private regexWhiteSpace = /^\\s*/;\r\n    private regexBoolean = /^#t|^#f/;\r\n    private regexComment = /^;.*/;\r\n\r\n    private tokens: Token[];\r\n    private itoken = 0;\r\n\r\n    public parse(st: string): SvCons {\r\n        this.tokens = this.getTokens(st)\r\n            .filter(token => token.kind !== TokenKind.WhiteSpace && token.kind !== TokenKind.Comment);\r\n        var lastToken = this.tokens.length ? this.tokens[this.tokens.length - 1]: null;\r\n        this.tokens.push(lastToken ?\r\n            new Token(TokenKind.EOF, \"\", lastToken.ilineEnd, lastToken.icolEnd + 1) :\r\n            new Token(TokenKind.EOF, \"\", 0,0) );\r\n        this.itoken = 0;\r\n\r\n        var rvs:Sv[] = [];\r\n        while (!this.accept(TokenKind.EOF))\r\n            rvs.push(this.parseExpression());\r\n\r\n        return SvCons.listFromRvArray(rvs);\r\n    }\r\n\r\n    private nextToken() {\r\n        if (this.itoken < this.tokens.length - 1)\r\n            this.itoken++;\r\n    }\r\n\r\n    private currentToken(): Token {\r\n        return this.tokens[this.itoken];\r\n    }\r\n\r\n    private accept(tokenKind: TokenKind) {\r\n        if (this.currentToken().kind === tokenKind) {\r\n\r\n            this.nextToken();\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    private expect(tokenKind: TokenKind) {\r\n        if (this.accept(tokenKind))\r\n            return true;\r\n        else\r\n            throw new Error('expected ' + tokenKind + ' found ' + this.currentToken().kind);\r\n    }\r\n\r\n    public parseExpression(): Sv {\r\n        var token = this.currentToken();\r\n\r\n        if (this.accept(TokenKind.Quote)) {\r\n            let svBody = this.parseExpression();\r\n            return new SvCons(new SvSymbol(\"quote\"), svBody).withSourceInfo(token, svBody);\r\n        }\r\n        if (this.accept(TokenKind.Symbol))\r\n            return new SvSymbol(token.st).withSourceInfo(token, token);\r\n        if (this.accept(TokenKind.BooleanLit)) \r\n            return SvBool.fromBoolean(token.st === \"#t\").withSourceInfo(token, token);\r\n        if (this.accept(TokenKind.NumberLit))\r\n            return new SvNumber(eval(token.st)).withSourceInfo(token, token);\r\n        if (this.accept(TokenKind.StringLit))\r\n            return new SvString(eval(token.st)).withSourceInfo(token, token);\r\n        if (this.accept(TokenKind.LParen)) {\r\n            let tokenStart = token;\r\n            let exprs:Sv[] = [];\r\n\r\n            while (!this.accept(TokenKind.RParen)) {\r\n\r\n                if (this.accept(TokenKind.EOF))\r\n                    throw new Error(\"unexpected end of input\");\r\n\r\n                exprs.push(this.parseExpression());\r\n            }\r\n\r\n            let tokenEnd = this.tokens[this.itoken - 1];\r\n            return SvCons.listFromRvArray(exprs).withSourceInfo(tokenStart, tokenEnd);\r\n        }\r\n\r\n        throw new Error(\"invalid token \" + token);\r\n    }\r\n\r\n    private getTokens(st: string): Token[] {\r\n        let tokens: Token[] = [];\r\n        let iline = 0;\r\n        let icol = 0;\r\n        while (st.length > 0) {\r\n            let ch = st[0];\r\n            let token: Token;\r\n\r\n            if (ch === \"(\")\r\n                token = new Token(TokenKind.LParen, ch, iline, icol);\r\n            else if (ch === \")\")\r\n                token = new Token(TokenKind.RParen, ch, iline, icol);\r\n            else if (ch === \"'\")\r\n                token = new Token(TokenKind.Quote, ch, iline, icol);\r\n            else if (this.regexNumber.test(st))\r\n                token = new Token(TokenKind.NumberLit, this.regexNumber.exec(st)[0], iline, icol);\r\n            else if (this.regexString.test(st))\r\n                token = new Token(TokenKind.StringLit, this.regexString.exec(st)[0], iline, icol);\r\n            else if (this.regexBoolean.test(st))\r\n                token = new Token(TokenKind.BooleanLit, this.regexBoolean.exec(st)[0], iline, icol);\r\n            else if (this.regexComment.test(st))\r\n                token = new Token(TokenKind.Comment, this.regexComment.exec(st)[0], iline, icol);\r\n            else if (this.regexSymbol.test(st))\r\n                token = new Token(TokenKind.Symbol, this.regexSymbol.exec(st)[0], iline, icol);\r\n            else if (this.regexWhiteSpace.test(st))\r\n                token = new Token(TokenKind.WhiteSpace, this.regexWhiteSpace.exec(st)[0], iline, icol);\r\n            else\r\n                throw new Error(\"invalid token at '\" + st + \"'\");\r\n            tokens.push(token);\r\n\r\n            if (token.st.length === 0)\r\n                throw new Error(\"invalid token\");\r\n            st = st.substr(token.st.length);\r\n            iline = token.ilineEnd;\r\n            icol = token.icolEnd;\r\n        }\r\n\r\n        return tokens;\r\n    }\r\n\r\n}\r\n\r\nexport interface ISourceInfo {\r\n    ilineStart:number;\r\n    icolStart:number;\r\n    ilineEnd:number;\r\n    icolEnd:number;\r\n}\r\n\r\n\r\n\r\nclass Token implements ISourceInfo {\r\n    public ilineEnd: number;\r\n    public icolEnd: number;\r\n\r\n    constructor(public kind: TokenKind, public st: string,\r\n        public ilineStart: number, public icolStart: number)\r\n    {\r\n        let lines = st.replace(\"\\r\", \"\").split('\\n');\r\n        this.ilineEnd = this.ilineStart + lines.length - 1;\r\n        if (this.ilineStart === this.ilineEnd)\r\n            this.icolEnd = icolStart + lines[0].length;\r\n        else\r\n            this.icolEnd = lines[lines.length-1].length;\r\n    }\r\n}","import { Sv, SvSymbol } from \"./sv\";\r\n\r\nexport class StackFrame {\r\n    constructor(private _sv: Sv, private _env: Env) {}\r\n    public sv(): Sv { return this._sv; }\r\n    public env(): Env { return this._env; }\r\n    public parent(): StackFrame { return this._env.getParentStackFrame(); }\r\n}\r\n\r\nexport class Env {\r\n    private obj: {[id: string] : Sv} = {};\r\n    private envParent: Env = null;\r\n    private svSymbolProcedure: SvSymbol;\r\n    private parentStackFrame: StackFrame;\r\n\r\n    constructor(envParent: Env, svSymbolProcedure: SvSymbol = null, parentStackFrame: StackFrame = null) {\r\n        this.envParent = envParent;\r\n        this.svSymbolProcedure = svSymbolProcedure;\r\n        this.parentStackFrame = parentStackFrame;\r\n    }\r\n\r\n    public getNames(): string[] {\r\n        const res: string[] = [];\r\n        for (let key in this.obj) {\r\n            if (this.obj.hasOwnProperty(key))\r\n                res.push(key);\r\n        }\r\n        return res;\r\n    }\r\n\r\n    public getEnvParent(): Env {\r\n        return this.envParent;\r\n    }\r\n\r\n    public getSvSymbolProcedure(): SvSymbol{\r\n        return this.svSymbolProcedure;\r\n    }\r\n\r\n    public getParentStackFrame(): StackFrame {\r\n        if (this.parentStackFrame)\r\n            return this.parentStackFrame;\r\n        if (this.envParent)\r\n            return this.envParent.getParentStackFrame();\r\n        return null;\r\n    }\r\n\r\n    public get(name: string):Sv {\r\n        if (name in this.obj)\r\n            return this.obj[name];\r\n        if (this.envParent == null)\r\n            throw new Error(\"no binding for \" + name);\r\n        return this.envParent.get(name);\r\n    }\r\n\r\n    public set(name: string, rv: Sv) {\r\n        if (name in this.obj)\r\n            this.obj[name] = rv;\r\n        else if (this.envParent == null)\r\n            throw new Error(name + \" is not declared\");\r\n        else\r\n            this.envParent.set(name, rv);\r\n    }\r\n\r\n    public define(name: string, value: Sv) {\r\n        if (name in this.obj)\r\n            throw new Error(name + ' is already defined');\r\n        this.obj[name] = value;\r\n    }\r\n\r\n    setOrDefine(name: string, value: Sv) {\r\n        this.obj[name] = value; \r\n    }\r\n}","import { Env } from \"./env\";\r\nimport { IEvaluator, Cont } from \"./ievaluator\";\r\nimport { Sv, SvBreakpoint, SvCons, SvThunk, SvSymbol } from \"./sv\";\r\n\r\nexport default class BaseEvaluator implements IEvaluator {\r\n    private stepCount: number = 1;\r\n    private step:number = 0 ;\r\n    private evaluators: IEvaluator[];\r\n\r\n    public setEvaluators(evaluators: IEvaluator[]) {\r\n        this.evaluators = evaluators;\r\n    }\r\n\r\n    public setStepCount(stepCount: number) {\r\n        this.stepCount = stepCount;\r\n        this.step = 0;\r\n    }\r\n\r\n    public matches(node: Sv): boolean {\r\n        return true;\r\n    }\r\n\r\n    public evaluate(sv: Sv, env: Env, cont: Cont): Sv {\r\n\r\n        for (var i = 0; i < this.evaluators.length;i++) {\r\n            if (this.evaluators[i].matches(sv)) {\r\n                this.step++;\r\n                if (this.step % this.stepCount === 0)\r\n                    return new SvBreakpoint(() => this.evaluators[i].evaluate(sv, env, cont), env).withSourceInfo(sv, sv);\r\n                else\r\n                    return this.evaluators[i].evaluate(sv, env, cont);\r\n\r\n            }\r\n        }\r\n        throw new Error('cannot evaluate ' + sv.toString());\r\n    }\r\n\r\n    public evaluateList(exprs: Sv, env: Env, cont: Cont): Sv {\r\n\r\n        var lastSv: Sv = SvCons.Nil;\r\n        var loop = (exprs: Sv): Sv => {\r\n            if (SvCons.isNil(exprs))\r\n                return new SvThunk(cont, lastSv);\r\n\r\n            return this.evaluate(SvCons.car(exprs), env, (sv: Sv) => {\r\n                lastSv = sv;\r\n                var nextExprs = SvCons.cdr(exprs);\r\n                return loop(nextExprs);\r\n            });\r\n        };\r\n\r\n        return loop(exprs);\r\n    }\r\n\r\n    public static isTaggedList(node: Sv, tag: string) {\r\n        if (!SvCons.matches(node)) return false;\r\n        var car = SvCons.car(node);\r\n        return SvSymbol.matches(car) && SvSymbol.val(car) === tag;\r\n    }\r\n}","import { StackFrame, Env } from \"./env\";\r\nimport { IEvaluator, Cont } from \"./ievaluator\";\r\nimport { Sv, SvCons, SvThunk, SvSymbol, SvAny } from \"./sv\";\r\nimport BaseEvaluator from \"./base-evaluator\";\r\n\r\nexport default class ApplicationEvaluator implements IEvaluator {\r\n\r\n    constructor(private evaluator: BaseEvaluator) { }\r\n    \r\n    public matches(sv: Sv): boolean {\r\n        return SvCons.matches(sv);\r\n    }\r\n\r\n    public static evalCall(operator:Sv, args: Sv, stackFrameCurrent:StackFrame,cont:Cont, evaluator:BaseEvaluator):Sv {\r\n            \r\n        if (this.isPrimitiveProcedure(operator)) {\r\n            return new SvThunk(cont, this.getPrimitiveProcedureDelegate(operator)(args));\r\n        }\r\n        else if (this.isContinuation(operator)) {\r\n            let arg: Sv = SvCons.Nil;\r\n            if (!SvCons.isNil(args)) {\r\n                if (!SvCons.isNil(SvCons.cdr(args)))\r\n                    throw new Error('too many arguments');\r\n                arg = SvCons.car(args);\r\n            }\r\n            return this.getContinuationFromCapturedContinuation(operator)(arg);\r\n        }\r\n        else if(this.isCompoundProcedure(operator)) {\r\n            const newEnv = new Env(this.getProcedureEnv(operator), this.getProcedureSymbol(operator), stackFrameCurrent);\r\n            let params = this.getProcedureParameters(operator);\r\n\r\n            while (!SvCons.isNil(args) || !SvCons.isNil(params)) {\r\n                if (SvCons.isNil(args))\r\n                    throw new Error('not enough argument');\r\n                if (SvCons.isNil(params))\r\n                    throw new Error('too many arguments');\r\n                const parameter = SvSymbol.val(SvCons.car(params));\r\n                const arg = SvCons.car(args);\r\n                newEnv.define(parameter, arg);\r\n\r\n                params = SvCons.cdr(params);\r\n                args = SvCons.cdr(args);\r\n            }\r\n            return evaluator.evaluateList(this.getProcedureBody(operator), newEnv, cont);\r\n        }\r\n        else\r\n            throw new Error('undefined procedure ' + operator.toString());\r\n    }\r\n        \r\n\r\n        public evaluate(sv: Sv, env: Env, cont: Cont): Sv {\r\n            return this.evaluator.evaluate(ApplicationEvaluator.getOperator(sv), env, (operator: Sv) => {\r\n            \r\n            if (!ApplicationEvaluator.isPrimitiveProcedure(operator) &&\r\n                !ApplicationEvaluator.isCompoundProcedure(operator) &&\r\n                !ApplicationEvaluator.isContinuation(operator))\r\n                throw new Error('undefined procedure ' + ApplicationEvaluator.getOperator(sv).toString());\r\n\r\n            return this.evaluateArgs(ApplicationEvaluator.getArguments(sv), env,\r\n                args => ApplicationEvaluator.evalCall(operator, args, new StackFrame(sv, env), cont, this.evaluator));\r\n        });\r\n        \r\n    }\r\n\r\n        private static isCompoundProcedure(expr: Sv) {\r\n            return BaseEvaluator.isTaggedList(expr, 'procedure'); \r\n            \r\n        }\r\n        private static isPrimitiveProcedure(expr: Sv) {\r\n            return BaseEvaluator.isTaggedList(expr, 'primitive'); \r\n            \r\n        }\r\n        private static isContinuation(expr: Sv) {\r\n            return BaseEvaluator.isTaggedList(expr, 'captured-continuation'); \r\n            \r\n        }\r\n    private static getContinuationFromCapturedContinuation(expr: Sv): Cont {\r\n        return SvAny.val(SvCons.cdr(expr)); \r\n    }\r\n\r\n    private static getProcedureSymbol(expr: Sv):SvSymbol { return SvSymbol.cast(SvCons.cadr(expr)); }\r\n    private static getProcedureParameters(expr: Sv) { return SvCons.caddr(expr); }\r\n    private static getProcedureBody(expr: Sv) { return SvCons.cadddr(expr); }\r\n    private static getProcedureEnv(expr: Sv): Env { return SvAny.val(SvCons.caddddr(expr)); }\r\n    private static getPrimitiveProcedureDelegate(expr: Sv) { return SvAny.val(SvCons.cdr(expr)); }\r\n    private static getOperator(expr: Sv) { return SvCons.car(expr); }\r\n    private static getArguments(expr: Sv) { return SvCons.cdr(expr); }\r\n\r\n    evaluateArgs(args0: Sv, env: Env, cont: Cont): Sv {\r\n        const evaluatedArgs = new SvCons(null, null);\r\n        const loop = (evaluatedArgsLast: Sv, args: Sv) :Sv => {\r\n            if (SvCons.isNil(args)) {\r\n                return new SvThunk(cont, evaluatedArgs);\r\n            }\r\n            return this.evaluator.evaluate(SvCons.car(args), env, (evaluatedArg: Sv) => {\r\n                SvCons.setCar(evaluatedArgsLast, evaluatedArg);\r\n                SvCons.setCdr(evaluatedArgsLast, new SvCons(null, null));\r\n                return loop(SvCons.cdr(evaluatedArgsLast), SvCons.cdr(args));\r\n            });\r\n        };\r\n        return loop(evaluatedArgs, args0);\r\n    }\r\n}","import { Env } from \"./env\";\r\nimport { IEvaluator, Cont } from \"./ievaluator\";\r\nimport { Sv, SvCons } from \"./sv\";\r\nimport BaseEvaluator from \"./base-evaluator\";\r\n\r\nexport default class BeginEvaluator implements IEvaluator {\r\n    constructor(private evaluator: BaseEvaluator) { }\r\n\r\n    public matches(node: Sv): boolean {\r\n        return BaseEvaluator.isTaggedList(node, 'begin');\r\n    }\r\n\r\n    public evaluate(sv: Sv, env: Env, cont: Cont): Sv {\r\n        return this.evaluator.evaluateList(this.getBeginActions(sv), env, cont);\r\n    }\r\n\r\n    getBeginActions(expr: Sv) { return SvCons.cdr(expr); }\r\n}","import { Env } from \"./env\";\r\nimport { IEvaluator, Cont } from \"./ievaluator\";\r\nimport { Sv, SvBreakpoint, SvThunk } from \"./sv\";\r\nimport BaseEvaluator from \"./base-evaluator\";\r\n\r\n    \r\nexport default class BreakpointEvaluator implements IEvaluator {\r\n    \r\n    constructor(private evaluator: BaseEvaluator) { }\r\n    \r\n    public matches(sv: Sv): boolean {\r\n        return SvBreakpoint.matches(sv);\r\n    }\r\n\r\n    public evaluate(sv: Sv, env: Env, cont: Cont): Sv {\r\n        return new SvThunk(cont, SvBreakpoint.cast(sv).val()());\r\n    }\r\n}","import { Env, StackFrame } from \"./env\";\r\nimport { IEvaluator, Cont } from \"./ievaluator\";\r\nimport { Sv, SvCons, SvSymbol, SvAny } from \"./sv\";\r\nimport ApplicationEvaluator from \"./application-evaluator\";\r\nimport BaseEvaluator from \"./base-evaluator\";\r\n\r\nexport default class CallCCEvaluator implements IEvaluator {\r\n\r\n    constructor(private evaluator: BaseEvaluator) { }\r\n    \r\n    public matches(sv: Sv): boolean {\r\n        return BaseEvaluator.isTaggedList(sv, 'call-with-current-continuation');\r\n    }\r\n\r\n    public evaluate(sv: Sv, env: Env, cont: Cont): Sv {\r\n        /* (call-with-current-continuation (lambda (hop) ...)) */\r\n        return this.evaluator.evaluate(this.getLambda(sv), env, lambda => {\r\n            var args = SvCons.listFromRvs(CallCCEvaluator.createCcProcedure(cont));\r\n            return ApplicationEvaluator.evalCall(lambda, args, new StackFrame(sv, env), cont, this.evaluator);\r\n        });\r\n    }\r\n\r\n    getLambda(sv: Sv) { return SvCons.cadr(sv); }\r\n\r\n    private static createCcProcedure(cont: Cont): Sv {\r\n        return new SvCons(new SvSymbol('captured-continuation'), new SvAny(cont));\r\n    }\r\n}","import { Env } from \"./env\";\r\nimport { IEvaluator, Cont } from \"./ievaluator\";\r\nimport { Sv, SvCons, SvThunk, SvBool } from \"./sv\";\r\nimport BaseEvaluator from \"./base-evaluator\";\r\n\r\nexport default class CondEvaluator implements IEvaluator {\r\n    constructor(private evaluator: BaseEvaluator) { }\r\n\r\n    public matches(node: Sv): boolean {\r\n        return BaseEvaluator.isTaggedList(node, 'cond');\r\n    }\r\n\r\n    private getCondClauses(cond: Sv) { return SvCons.cdr(cond); }\r\n    private isCondElseClause(clause: Sv) { return BaseEvaluator.isTaggedList(clause, \"else\"); }\r\n    private getCondPredicate(clause: Sv) { return SvCons.car(clause); }\r\n    private getCondActions(clause: Sv) { return SvCons.cdr(clause); }\r\n\r\n    public evaluate(sv: Sv, env: Env, cont: Cont): Sv {\r\n\r\n        var loop = (clauses: Sv): Sv => {\r\n            if (SvCons.isNil(clauses))\r\n                return new SvThunk(cont, clauses);\r\n\r\n            var clause = SvCons.car(clauses);\r\n            if (this.isCondElseClause(clause))\r\n                return this.evaluator.evaluateList(this.getCondActions(clause), env, cont);\r\n\r\n            return this.evaluator.evaluate(SvCons.car(clause), env, (svCond: Sv) => {\r\n                if (SvBool.isTrue(svCond))\r\n                    return this.evaluator.evaluateList(this.getCondActions(clause), env, cont);\r\n                else {\r\n                    var nextClauses = SvCons.cdr(clauses);\r\n                    return loop(nextClauses);\r\n                }\r\n            });\r\n        };\r\n\r\n        var clauses = this.getCondClauses(sv);\r\n        return loop(clauses);\r\n    }\r\n}","import { Env } from \"./env\";\r\nimport { IEvaluator, Cont } from \"./ievaluator\";\r\nimport { Sv, SvSymbol, SvThunk, SvCons, SvAny } from \"./sv\";\r\nimport BaseEvaluator from \"./base-evaluator\";\r\n\r\nexport default class LambdaEvaluator implements IEvaluator {\r\n    constructor(private evaluator: BaseEvaluator) {  }\r\n\r\n    public matches(node: Sv): boolean {\r\n        return BaseEvaluator.isTaggedList(node, 'lambda');\r\n    }\r\n\r\n    public evaluate(sv: Sv, env: Env, cont: Cont): Sv {\r\n        var proc = LambdaEvaluator.createCompoundProcedure(\r\n            new SvSymbol(\"lambda\"),\r\n            LambdaEvaluator.getLambdaParameters(sv),\r\n            LambdaEvaluator.getLambdaBody(sv),\r\n            env);\r\n        return new SvThunk(cont, proc);\r\n    }\r\n\r\n    public static createCompoundProcedure(name:SvSymbol, params: Sv, body: Sv, env: Env):Sv {\r\n        return SvCons.listFromRvs(\r\n            new SvSymbol('procedure'),\r\n            name,\r\n            params,\r\n            body,\r\n            new SvAny(env));\r\n    }\r\n    public static getLambdaParameters(expr: Sv) { return SvCons.cadr(expr); }\r\n    public static getLambdaBody(expr: Sv) { return SvCons.cddr(expr); }\r\n\r\n}","import { Env } from \"./env\";\r\nimport { IEvaluator, Cont } from \"./ievaluator\";\r\nimport { Sv, SvCons, SvSymbol, SvThunk } from \"./sv\";\r\nimport BaseEvaluator from \"./base-evaluator\";\r\nimport LambdaEvaluator from \"./lambda-evaluator\";\r\n\r\nexport default class DefineEvaluator implements IEvaluator {\r\n    constructor(private evaluator: BaseEvaluator) {  }\r\n\r\n    public matches(node: Sv): boolean {\r\n        return BaseEvaluator.isTaggedList(node, 'define');\r\n    }\r\n\r\n    public evaluate(sv: Sv, env: Env, cont: Cont): Sv {\r\n\r\n        if (SvCons.matches(this.getHead(sv))) {\r\n            //implicit lambda definition\r\n            var lambda = LambdaEvaluator.createCompoundProcedure(\r\n                this.getFunctionName(sv) as SvSymbol, this.getLambdaParameters(sv), this.getLambdaBody(sv), env);\r\n            env.define(\r\n                SvSymbol.val(this.getFunctionName(sv)),\r\n                lambda);\r\n            return new SvThunk(cont, lambda);\r\n        }\r\n        else {\r\n            return this.evaluator.evaluate(this.getValue(sv), env, (svValue: Sv):Sv => {\r\n                env.define(\r\n                    SvSymbol.val(this.getVariable(sv)),\r\n                    svValue);\r\n                return new SvThunk(cont, svValue);\r\n            });\r\n        }\r\n    }\r\n\r\n    getHead(sv: Sv): Sv { return SvCons.cadr(sv); }\r\n    getVariable(sv: Sv): Sv { return this.getHead(sv); }\r\n    getValue(sv: Sv): Sv { return SvCons.caddr(sv); }\r\n\r\n    getFunctionName(sv: Sv): Sv { return SvCons.car(this.getHead(sv)); }\r\n    getLambdaParameters(sv: Sv) { return SvCons.cdr(this.getHead(sv)); }\r\n    getLambdaBody(sv: Sv) { return SvCons.cddr(sv); }\r\n}","import { Env } from \"./env\";\r\nimport { IEvaluator, Cont } from \"./ievaluator\";\r\nimport { Sv, SvBool, SvCons } from \"./sv\";\r\nimport BaseEvaluator from \"./base-evaluator\";\r\n\r\nexport default class IfEvaluator implements IEvaluator {\r\n    constructor(private evaluator: BaseEvaluator) {  }\r\n\r\n    public matches(node: Sv): boolean {\r\n        return BaseEvaluator.isTaggedList(node, 'if');\r\n    }\r\n\r\n    public evaluate(sv: Sv, env: Env, cont: Cont): Sv {\r\n        return this.evaluator.evaluate(this.getIfPredicate(sv), env, (svCond: Sv) => {\r\n            return SvBool.isTrue(svCond) ?\r\n                this.evaluator.evaluate(this.getIfConsequent(sv), env, cont):\r\n                this.evaluator.evaluate(this.getIfAlternative(sv), env, cont);\r\n        });\r\n    }\r\n\r\n    getIfPredicate(expr: any) { return SvCons.cadr(expr); }\r\n    getIfConsequent(expr: any) { return SvCons.caddr(expr); }\r\n    getIfAlternative(expr: any) { return !SvCons.isNil(SvCons.cdddr(expr)) ? SvCons.cadddr(expr) : SvCons.Nil; }\r\n\r\n}","import { Env } from \"./env\";\r\nimport { IEvaluator, Cont } from \"./ievaluator\";\r\nimport { Sv, SvCons, SvSymbol } from \"./sv\";\r\nimport BaseEvaluator from \"./base-evaluator\";\r\n\r\nexport default class LetEvaluator implements IEvaluator {\r\n    constructor(private evaluator: BaseEvaluator) { }\r\n\r\n    public matches(node: Sv): boolean {\r\n        return LetEvaluator.isLet(node) || LetEvaluator.isLetStar(node) || LetEvaluator.isLetrec(node);\r\n    }\r\n\r\n    public evaluate(sv: Sv, env: Env, cont: Cont): Sv {\r\n\r\n        if (LetEvaluator.isLet(sv)) {\r\n            const loop = (letEnv: Env, defs: Sv): Sv => {\r\n                if (SvCons.isNil(defs)) \r\n                    return this.evaluator.evaluateList(LetEvaluator.getBody(sv), letEnv, cont);\r\n                \r\n                const def = SvCons.car(defs);\r\n                const svSymbol = SvCons.car(def);\r\n                return this.evaluator.evaluate(SvCons.cadr(def), env, (svValue) => {\r\n                    letEnv.define(SvSymbol.val(svSymbol), svValue);\r\n                    return loop(letEnv, SvCons.cdr(defs));\r\n                });\r\n            };\r\n            return loop(new Env(env), LetEvaluator.getDefs(sv));\r\n\r\n        }\r\n        else if (LetEvaluator.isLetStar(sv)) {\r\n            const loop = (letEnv:Env, defs: Sv): Sv => {\r\n                if (SvCons.isNil(defs)) \r\n                    return this.evaluator.evaluateList(LetEvaluator.getBody(sv), letEnv, cont);\r\n                \r\n                const def = SvCons.car(defs);\r\n                const svSymbol = SvCons.car(def);\r\n                return this.evaluator.evaluate(SvCons.cadr(def), letEnv, (svValue) => {\r\n                    letEnv = new Env(letEnv);\r\n                    letEnv.setOrDefine(SvSymbol.val(svSymbol), svValue);\r\n                    return loop(letEnv, SvCons.cdr(defs));\r\n                });\r\n            };\r\n            return loop(env, LetEvaluator.getDefs(sv));\r\n        }\r\n        else if (LetEvaluator.isLetrec(sv)) {\r\n            const newEnv = new Env(env); \r\n            let defsT = LetEvaluator.getDefs(sv);\r\n            while (!SvCons.isNil(defsT)) {\r\n                const def = SvCons.car(defsT);\r\n                newEnv.define(SvSymbol.val(SvCons.car(def)), SvCons.Nil);\r\n                defsT = SvCons.cdr(defsT);\r\n            }\r\n\r\n            const loop = (letEnv: Env, defs: Sv): Sv => {\r\n                if (SvCons.isNil(defs))\r\n                    return this.evaluator.evaluateList(LetEvaluator.getBody(sv), letEnv, cont);\r\n                \r\n                const def = SvCons.car(defs);\r\n                const svSymbol = SvCons.car(def);\r\n                return this.evaluator.evaluate(SvCons.cadr(def), letEnv, (svValue) => {\r\n                    letEnv.set(SvSymbol.val(svSymbol), svValue);\r\n                    return loop(letEnv, SvCons.cdr(defs));\r\n                });\r\n            };\r\n\r\n            return loop(newEnv, LetEvaluator.getDefs(sv));\r\n        }\r\n        else\r\n            throw new Error('uknown let kind');\r\n\r\n        \r\n    }\r\n\r\n    static isLet(node: Sv): boolean { return BaseEvaluator.isTaggedList(node, 'let'); }\r\n    static isLetStar(node: Sv): boolean { return BaseEvaluator.isTaggedList(node, 'let*'); }\r\n    static isLetrec(node: Sv): boolean { return BaseEvaluator.isTaggedList(node, 'letrec'); }\r\n\r\n    static getDefs(sv: Sv) {\r\n        return SvCons.cadr(sv);\r\n    }\r\n\r\n    static getBody(sv: Sv): Sv { return SvCons.cddr(sv); }\r\n}","import { Env } from \"./env\";\r\nimport { IEvaluator, Cont } from \"./ievaluator\";\r\nimport { Sv, SvCons, SvThunk } from \"./sv\";\r\nimport BaseEvaluator from \"./base-evaluator\";\r\n\r\nexport default class QuoteEvaluator implements IEvaluator {\r\n    constructor(private evaluator: BaseEvaluator) { }\r\n    public matches(node: Sv): boolean {\r\n        return BaseEvaluator.isTaggedList(node, 'quote');\r\n    }\r\n\r\n    public evaluate(sv: Sv, env: Env, cont: Cont): Sv {\r\n        var res = SvCons.cdr(sv);\r\n        return new SvThunk(cont, res);\r\n    }\r\n}","import { Env } from \"./env\";\r\nimport { IEvaluator, Cont } from \"./ievaluator\";\r\nimport { Sv, SvString, SvBool, SvNumber, SvCons, SvThunk } from \"./sv\";\r\n\r\nexport default class SelfEvaluator implements IEvaluator {\r\n    public matches(node: Sv): boolean {\r\n        return SvString.matches(node) || SvBool.matches(node) ||\r\n            SvNumber.matches(node) || SvCons.isNil(node);\r\n    }\r\n\r\n    public evaluate(sv: Sv, env: Env, cont: Cont): Sv {\r\n        return new SvThunk(cont, sv);\r\n    }\r\n}","import { Env } from \"./env\";\r\nimport { IEvaluator, Cont } from \"./ievaluator\";\r\nimport { Sv, SvSymbol, SvThunk } from \"./sv\";\r\n\r\nexport default class VariableEvaluator implements IEvaluator {\r\n    public matches(node: Sv): boolean {\r\n        return SvSymbol.matches(node);\r\n    }\r\n\r\n    public evaluate(sv: Sv, env: Env, cont: Cont): Sv {\r\n        var res = env.get(SvSymbol.val(sv));\r\n        return new SvThunk(cont, res);\r\n    }\r\n}","import { Env } from \"./env\";\r\nimport { IEvaluator, Cont } from \"./ievaluator\";\r\nimport { Sv, SvSymbol, SvThunk, SvCons } from \"./sv\";\r\nimport BaseEvaluator from \"./base-evaluator\";\r\n\r\nexport default class AssignmentEvaluator implements IEvaluator {\r\n    constructor(private evaluator: BaseEvaluator) {  }\r\n\r\n    public matches(sv: Sv): boolean {\r\n        return BaseEvaluator.isTaggedList(sv, 'set!');\r\n    }\r\n\r\n    public evaluate(sv: Sv, env: Env, cont: Cont): Sv {\r\n\r\n        return this.evaluator.evaluate(this.getValue(sv), env, (svValue) => {\r\n            env.set(\r\n                SvSymbol.val(this.getVariable(sv)),\r\n                svValue);\r\n            return new SvThunk(cont, svValue);\r\n        });\r\n    }\r\n\r\n    getVariable(node: Sv): Sv { return SvCons.cadr(node); }\r\n    getValue(node: Sv): Sv { return SvCons.caddr(node); }\r\n}","import { Env } from \"./env\";\r\nimport { Parser } from \"./parser\";\r\nimport { SvCons, SvSymbol, SvAny, SvBool, SvNumber, Sv, SvBreakpoint, SvThunk } from \"./sv\";\r\nimport BaseEvaluator from \"./base-evaluator\";\r\nimport ApplicationEvaluator from \"./application-evaluator\";\r\nimport BeginEvaluator from \"./begin-evaluator\";\r\nimport BreakpointEvaluator from \"./breakpoint-evaluator\";\r\nimport CallCCEvaluator from \"./call-cc-evaluator\";\r\nimport CondEvaluator from \"./cond-evaluator\";\r\nimport DefineEvaluator from \"./define-evaluator\";\r\nimport IfEvaluator from \"./if-evaluator\";\r\nimport LambdaEvaluator from \"./lambda-evaluator\";\r\nimport LetEvaluator from \"./let-evaluator\";\r\nimport QuoteEvaluator from \"./quote-evaluator\";\r\nimport SelfEvaluator from \"./self-evaluator\";\r\nimport VariableEvaluator from \"./variable-evaluator\";\r\nimport AssignmentEvaluator from \"./assignment-evaluator\";\r\n\r\nexport class Interpreter {\r\n\r\n    private evaluator: BaseEvaluator;\r\n\r\n    public evaluateString(st: string, log: (st: string) => void) {\r\n        let parser = new Parser();\r\n        let exprs = parser.parse(st);\r\n        let env = new Env(null);\r\n        env.define('cons', new SvCons(new SvSymbol('primitive'), new SvAny((args: any) => new SvCons(SvCons.car(args), SvCons.cadr(args)))));\r\n        env.define('null?', new SvCons(new SvSymbol('primitive'), new SvAny((args: any) => SvBool.fromBoolean(SvCons.isNil(SvCons.car(args))))));\r\n        env.define('car', new SvCons(new SvSymbol('primitive'), new SvAny((args: any) => SvCons.car(SvCons.car(args)))));\r\n        env.define('cadr', new SvCons(new SvSymbol('primitive'), new SvAny((args: any) => SvCons.cadr(SvCons.car(args)))));\r\n        env.define('cdr', new SvCons(new SvSymbol('primitive'), new SvAny((args: any) => SvCons.cdr(SvCons.car(args)))));\r\n        env.define('=', new SvCons(new SvSymbol('primitive'), new SvAny((args: any) => SvBool.fromBoolean(SvNumber.val(SvCons.car(args)) === SvNumber.val(SvCons.cadr(args))))));\r\n        env.define('>', new SvCons(new SvSymbol('primitive'), new SvAny((args: any) => SvBool.fromBoolean(SvNumber.val(SvCons.car(args)) > SvNumber.val(SvCons.cadr(args))))));\r\n        env.define('<', new SvCons(new SvSymbol('primitive'), new SvAny((args: any) => SvBool.fromBoolean(SvNumber.val(SvCons.car(args)) < SvNumber.val(SvCons.cadr(args))))));\r\n        env.define('*', new SvCons(new SvSymbol('primitive'), new SvAny((args: any) => new SvNumber(SvNumber.val(SvCons.car(args)) * SvNumber.val(SvCons.cadr(args))))));\r\n        env.define('-', new SvCons(new SvSymbol('primitive'), new SvAny((args: any) => new SvNumber(SvNumber.val(SvCons.car(args)) - SvNumber.val(SvCons.cadr(args))))));\r\n        env.define('+', new SvCons(new SvSymbol('primitive'), new SvAny((args: any) => new SvNumber(SvNumber.val(SvCons.car(args)) + SvNumber.val(SvCons.cadr(args))))));\r\n        env.define('/', new SvCons(new SvSymbol('primitive'), new SvAny((args: any) => new SvNumber(SvNumber.val(SvCons.car(args)) / SvNumber.val(SvCons.cadr(args))))));\r\n        env.define('min', new SvCons(new SvSymbol('primitive'), new SvAny((args: any) => new SvNumber(Math.min(SvNumber.val(SvCons.car(args)), SvNumber.val(SvCons.cadr(args)))))));\r\n        env.define('max', new SvCons(new SvSymbol('primitive'), new SvAny((args: any) => new SvNumber(Math.max(SvNumber.val(SvCons.car(args)), SvNumber.val(SvCons.cadr(args)))))));\r\n        env.define('abs', new SvCons(new SvSymbol('primitive'), new SvAny((args: any) => new SvNumber(Math.abs(SvNumber.val(SvCons.car(args)))))));\r\n        env.define('zero?', new SvCons(new SvSymbol('primitive'), new SvAny((args: any) => SvBool.fromBoolean(SvNumber.val(SvCons.car(args)) === 0))));\r\n        env.define('length', new SvCons(new SvSymbol('primitive'), new SvAny((args: any) => SvCons.lengthI(SvCons.car(args)))));\r\n        env.define('not', new SvCons(new SvSymbol('primitive'), new SvAny((args: any) => SvBool.not(SvCons.car(args)))));\r\n        env.define('and', new SvCons(new SvSymbol('primitive'), new SvAny((args: any) => SvBool.and(args))));\r\n        env.define('or', new SvCons(new SvSymbol('primitive'), new SvAny((args: any) => SvBool.or(args))));\r\n        env.define('display', new SvCons(new SvSymbol('primitive'), new SvAny((args: any) => {\r\n            while (!SvCons.isNil(args)) {\r\n                log(SvCons.car(args).toDisplayString());\r\n                args = SvCons.cdr(args);\r\n            }\r\n            return SvCons.Nil;\r\n        })));\r\n        env.define('newline', new SvCons(new SvSymbol('primitive'), new SvAny((args: any) => {\r\n            log('\\n');\r\n            return SvCons.Nil;\r\n        })));\r\n        this.evaluator = new BaseEvaluator();\r\n        this.evaluator.setEvaluators([\r\n            new BreakpointEvaluator(this.evaluator),\r\n            new SelfEvaluator(),\r\n            new VariableEvaluator(),\r\n            new LetEvaluator(this.evaluator),\r\n            new QuoteEvaluator(this.evaluator),\r\n            new CondEvaluator(this.evaluator),\r\n            new DefineEvaluator(this.evaluator),\r\n            new AssignmentEvaluator(this.evaluator),\r\n            new IfEvaluator(this.evaluator),\r\n            new BeginEvaluator(this.evaluator),\r\n            new LambdaEvaluator(this.evaluator),\r\n            new CallCCEvaluator(this.evaluator),\r\n            new ApplicationEvaluator(this.evaluator)\r\n        ]);\r\n\r\n        return this.evaluator.evaluateList(exprs, new Env(env), sv => {\r\n            //log(sv.toString());\r\n            return sv;\r\n        });\r\n    }\r\n\r\n    public step(sv: Sv, stepCount: number): Sv {\r\n    \r\n        this.evaluator.setStepCount(stepCount);\r\n\r\n        if (SvBreakpoint.matches(sv)) {\r\n            sv = SvBreakpoint.cast(sv).val()();\r\n            while (SvThunk.matches(sv))\r\n                sv = SvThunk.call(sv);\r\n        }\r\n    \r\n        return SvBreakpoint.matches(sv) ? sv : null;\r\n    }\r\n\r\n}","import { StackFrame } from \"../lang/env\";\nimport { Sv, SvBreakpoint } from \"../lang/sv\";\n\nexport type DebuggerState = {\n    kind: \"stopped\"\n} | {\n    kind: \"running\" | \"step\",\n    sv: Sv\n} | {\n    kind: \"paused\",\n    sv: SvBreakpoint,\n    currentStackFrameIndex: number\n};\n\nexport function getCurrentStackFrame(debuggerState: DebuggerState): StackFrame {\n    if (debuggerState.kind !== \"paused\") {\n        return null;\n    }\n\n    let stackFrame = new StackFrame(debuggerState.sv, debuggerState.sv.env());\n    for (let i = 0; stackFrame && i < debuggerState.currentStackFrameIndex; i++) {\n        stackFrame = stackFrame.parent();\n    }\n    return stackFrame;\n}\n","import React from 'react';\n\nexport type SampleProps = {\n    samples: string[],\n    onSampleSelected: (index: number) => void;\n}\n\nexport const Samples: React.FC<SampleProps> = (props: SampleProps) => {\n\n    const options = props.samples.map(sample => {\n        let text = sample.split('\\n')[0].trim().replace(/^; /, '');\n        return <option key={sample}>{text}</option>\n    });\n\n    const onChange: React.ChangeEventHandler<HTMLSelectElement> = (event) => {\n        props.onSampleSelected(event.target.selectedIndex);\n    };\n    return <select\n        className=\"sicp-editor-select-sample\"\n        onChange={onChange}>\n        {options}\n    </select>\n}\n","import React from 'react';\nimport { SampleProps, Samples } from \"./samples\";\n\nexport type ToolbarProps = SampleProps & {\n    onRun?: () => void;\n    onPause?: () => void;\n    onStop?: () => void;\n    onStep?: () => void;\n    onContinue?: () => void;\n}\n\nexport const Toolbar: React.FC<ToolbarProps> = (props) => {\n    return <div className=\"sicp-editor-toolbar\">\n        {props.onRun && <button className=\"sicp-editor-button\" onClick={props.onRun}>run</button>}\n        {props.onPause && <button className=\"sicp-editor-button\" onClick={props.onPause}>pause</button>}\n        {props.onStop && <button className=\"sicp-editor-button\" onClick={props.onStop}>stop</button>}\n        {props.onStep && <button className=\"sicp-editor-button\" onClick={props.onStep}>step</button>}\n        {props.onContinue && <button className=\"sicp-editor-button\" onClick={props.onContinue}>continue</button>}\n        <Samples samples={props.samples} onSampleSelected={props.onSampleSelected} />\n    </div>\n}\n","import React from 'react';\nimport { DebuggerState, getCurrentStackFrame } from \"./debugger-state\";\n\nexport type ScopesProps = {\n    debuggerState: DebuggerState,\n}\n\nexport const Scopes: React.FC<ScopesProps> = (props) => {\n\n    const debuggerState = props.debuggerState;\n    let stackFrame = getCurrentStackFrame(debuggerState)\n    if (stackFrame == null) {\n        return <div />;\n    }\n\n    let env = stackFrame.env();\n    let scopes: React.ReactElement[] = [];\n    while (env) {\n        //                 $(pTitle).click(() => { $(divScope).toggleClass('sicp-tree-node-collapsed'); });\n\n        scopes.push(<div>\n            <p className=\"sicp-tree-node-title\">Scope</p>\n            {env.getNames().length > 0 &&\n                <div className=\"sicp-tree-node-content\">\n                    {\n                        env.getNames().map(name =>\n                            <div key={name}>\n                                <div className=\"sicp-variable-name\">{name}</div>\n                                <div className=\"sicp-variable-value\">{env.get(name).toDisplayString()}</div>\n                            </div>\n                        )\n                    }\n                </div>\n            }\n            {env.getNames().length === 0 && <p className=\"sicp-scope-empty\">« empty »</p>}\n        </div>\n        );\n        env = env.getEnvParent();\n    }\n    return <div>{scopes}</div>\n}","import React from 'react';\nimport { StackFrame } from \"../lang/env\";\nimport { SvBreakpoint } from \"../lang/sv\";\nimport { DebuggerState } from \"./debugger-state\";\n\nexport type StacktraceProps = {\n    debuggerState: DebuggerState,\n    onStackFrameSelect: (i: number) => void\n}\n\nexport const Stacktrace: React.FC<StacktraceProps> = (props) => {\n    const debuggerState = props.debuggerState;\n    if (debuggerState.kind !== \"paused\" || !SvBreakpoint.matches(debuggerState.sv)) {\n        return <div />\n    }\n\n    const sv = debuggerState.sv;\n    let stackFrame = new StackFrame(sv, sv.env());\n    let stackFrameIndex = 0;\n    let frameElements: React.ReactElement[] = [];\n    while (stackFrame) {\n        const currentStackFrame = stackFrameIndex;\n        let env = stackFrame.env();\n        while (env != null && env.getSvSymbolProcedure() == null)\n            env = env.getEnvParent();\n\n        const classes = 'sicp-stack-frame ' + ((currentStackFrame === debuggerState.currentStackFrameIndex) ? 'sicp-stack-frame-current' : '');\n        frameElements.push(\n            <div className={classes} key={stackFrameIndex} onClick={() => props.onStackFrameSelect(currentStackFrame)}>\n                <p>{!env ? \"« not in procedure »\" : env.getSvSymbolProcedure().toString()}</p>\n            </div>\n        );\n        stackFrame = stackFrame.parent();\n        stackFrameIndex++;\n    }\n\n    return <div>{frameElements}</div>;\n}","export default class Logger {\n    output: string;\n    clear() {\n        this.output = \"\";\n    }\n    log = (st: string) => {\n        this.output += st;\n    }\n}\n","import React from 'react';\nexport type NewLineTextProps = {\n    text: string\n}\n\nexport const NewLineText: React.FC<NewLineTextProps> = (props) => {\n    if(!props.text) {\n        return <div/>;\n    }\n\n    const text = props.text;\n    const newText = text.split('\\n').map(str => <div>{str}</div>);\n    return <div>{newText}</div>;\n}\n","import React from 'react';\nimport AceEditor from \"react-ace\";\n\nimport \"brace/mode/typescript\";\nimport \"brace/theme/tomorrow_night\";\nimport { Interpreter } from '../lang/interpreter';\nimport { SvBreakpoint } from '../lang/sv';\nimport { IMarker } from 'react-ace/lib/types';\nimport { DebuggerState, getCurrentStackFrame } from './debugger-state';\nimport { Toolbar } from './toolbar';\nimport { Scopes } from './scopes';\nimport { Stacktrace } from './stacktrace';\nimport Logger from './logger';\nimport { NewLineText } from './new-line-text';\n\nexport type EditorProps = {\n    sampleUrls: string[]\n}\n\nexport type EditorState = {\n    samples: string[];\n    program: string;\n    currentSampleIndex: number;\n    logger: Logger;\n    interpreter: Interpreter;\n    debuggerState: DebuggerState;\n    editorRef: React.RefObject<AceEditor>;\n}\n\nexport class Editor extends React.PureComponent<EditorProps, EditorState> {\n    constructor(props: EditorProps) {\n        super(props);\n\n        this.state = {\n            program: '',\n            samples: [],\n            currentSampleIndex: 0,\n            logger: new Logger(),\n            interpreter: new Interpreter(),\n            debuggerState: { kind: \"stopped\" },\n            editorRef: React.createRef()\n        }\n\n        const fetchSamples = async () => {\n            const samples: string[] = [];\n            for (let url of props.sampleUrls) {\n                const response = await fetch(url);\n                samples.push(await response.text());\n            }\n            return samples;\n        }\n        fetchSamples().then(\n            (samples) => {\n                this.setState({ samples: samples });\n                this.setSampleIndex(0);\n            }\n        );\n    }\n\n    setSampleIndex = (index: number) => {\n        this.stop();\n        this.setState({\n            program: this.state.samples[index] ?? \"\",\n            currentSampleIndex: index,\n        });\n    };\n\n    run = () => {\n        this.setState({ debuggerState: { kind: \"running\", sv: null } });\n    }\n\n    stop = () => {\n        if (this.state.debuggerState.kind !== \"stopped\") {\n            this.setState({ debuggerState: { kind: \"stopped\" } });\n        }\n    };\n\n    step = () => {\n        const { debuggerState } = this.state;\n        if (debuggerState.kind === \"paused\") {\n            this.setState({ debuggerState: { ...debuggerState, kind: \"step\" } });\n        } else if (debuggerState.kind === \"stopped\") {\n            this.setState({ debuggerState: { kind: \"step\", sv: null } });\n        }\n    };\n\n    cont = () => {\n        const { debuggerState } = this.state;\n        if (debuggerState.kind === \"paused\") {\n            this.setState({ debuggerState: { ...debuggerState, kind: \"running\" } });\n        }\n    };\n\n    pause = () => {\n        const { debuggerState } = this.state;\n\n        if (debuggerState.kind === \"running\" && SvBreakpoint.matches(debuggerState.sv)) {\n            this.setState({\n                debuggerState: {\n                    kind: \"paused\",\n                    sv: debuggerState.sv,\n                    currentStackFrameIndex: 0\n                }\n            });\n        }\n    };\n\n    setStackFrameIndex = (index: number) => {\n        const { debuggerState } = this.state;\n        if (debuggerState.kind === \"paused\") {\n            this.setState({\n                debuggerState: { ...debuggerState, kind: \"paused\", currentStackFrameIndex: index }\n            });\n        }\n    };\n\n    edit = (program: string) => {\n        this.stop();\n        this.setState({ program });\n    }\n\n    stepInterpreter = () => {\n        const { debuggerState, interpreter, logger, program } = this.state;\n\n        if (debuggerState.kind === \"running\" || debuggerState.kind === \"step\") {\n            try {\n                let sv = debuggerState.sv;\n                if (sv == null) {\n                    this.stop();\n                    logger.clear();\n                    sv = interpreter.evaluateString(program, logger.log);\n                } else {\n                    sv = interpreter.step(debuggerState.sv, debuggerState.kind === \"running\" ? 10000 : 1);\n                }\n\n                if (sv == null) {\n                    this.setState({ debuggerState: { kind: \"stopped\" } });\n                } else if (debuggerState.kind === \"running\") {\n                    this.setState({ debuggerState: { kind: \"running\", sv } });\n                } else if (SvBreakpoint.matches(sv)) {\n                    this.setState({ debuggerState: { kind: \"paused\", sv, currentStackFrameIndex: 0 } });\n                } else {\n                    this.setState({ debuggerState: { kind: \"stopped\" } });\n                }\n            } catch (ex) {\n                console.log(ex);\n                logger.log(\"\\n\" + ex);\n                this.setState({ debuggerState: { kind: \"stopped\" } });\n            }\n        }\n    }\n\n    render() {\n        const { samples, debuggerState, editorRef, logger, program } = this.state;\n\n        if (debuggerState.kind === \"running\" || debuggerState.kind === \"step\") {\n            setTimeout(this.stepInterpreter, 0);\n        }\n\n        const markers: IMarker[] = [];\n\n        const stackFrame = getCurrentStackFrame(debuggerState);\n        if (debuggerState.kind === \"paused\" && stackFrame != null) {\n            markers.push({\n                startRow: stackFrame.sv().ilineStart,\n                endRow: stackFrame.sv().ilineEnd,\n                startCol: stackFrame.sv().icolStart,\n                endCol: stackFrame.sv().icolEnd,\n                className: \"current-statement\",\n                type: \"text\"\n            });\n            editorRef.current?.editor.gotoLine(stackFrame.sv().ilineStart);\n        }\n\n        return (\n            <div id=\"editor-wrap\">\n                <div id=\"editor\">\n                    <Toolbar\n                        samples={samples}\n                        onSampleSelected={this.setSampleIndex}\n                        onRun={debuggerState.kind === \"stopped\" ? this.run : null}\n                        onStop={debuggerState.kind === \"paused\" || debuggerState.kind === \"running\" ? this.stop : null}\n                        onPause={debuggerState.kind === \"running\" ? this.pause : null}\n                        onStep={debuggerState.kind === \"paused\" || debuggerState.kind === \"stopped\" ? this.step : null}\n                        onContinue={debuggerState.kind === \"paused\" ? this.cont : null}\n                    />\n                    <AceEditor\n                        ref={editorRef}\n                        onChange={this.edit}\n                        className=\"editorWindow\"\n                        mode=\"typescript\"\n                        theme=\"tomorrow_night\"\n                        name=\"ace-editor\"\n                        editorProps={{ $blockScrolling: false }}\n                        value={program}\n                        showGutter={true}\n                        width=\"auto\"\n                        height=\"auto\"\n                        markers={markers}\n                    />\n                </div>\n                <div id=\"editor-bottom\">\n                    <div className=\"sicp-box\">\n                        <p className=\"sicp-box-tab-title\">Output</p>\n                        <div id=\"output-content\" className=\"sicp-box-tab-content\"><NewLineText text={logger.output} /></div>\n                    </div>\n                    <div className=\"sicp-box\">\n                        <p className=\"sicp-box-tab-title\">Stacktrace</p>\n                        <div id=\"stacktrace-content\" className=\"sicp-box-tab-content\">\n                            <Stacktrace debuggerState={debuggerState} onStackFrameSelect={this.setStackFrameIndex} />\n                        </div>\n                    </div>\n                    <div className=\"sicp-box\">\n                        <p className=\"sicp-box-tab-title\">Variables</p>\n                        <div id=\"variables-content\" className=\"sicp-box-tab-content\">\n                            <Scopes debuggerState={debuggerState} />\n                        </div>\n                    </div>\n                </div>\n            </div>\n        );\n    }\n}","import React from 'react';\n\nimport \"./App.css\";\nimport {Editor} from './editor/editor';\n\nconst samples = [\n    'samples/factorial.ms',\n    'samples/odd-or-even.ms',\n    'samples/counting-change.ms',\n    'samples/hanoi.ms',\n    'samples/n-queens.ms',\n    'samples/return-with-callcc.ms',\n    'samples/lazy-generator.ms',\n    'samples/yin-yang.ms'\n]\n\nfunction App() {\n    return (\n        <>\n            <div id=\"header\">\n                <h2>Mini scheme</h2>\n                <p>by <a href=\"https://csokavar.hu\">encse</a></p>\n            </div>\n            <Editor sampleUrls={samples}/>\n            <div id=\"footer\">Copyright 2015, source is available on <a href=\"https://github.com/encse/sicp\">GitHub</a></div>\n        </>\n    );\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\n\nconst rootElement = document.getElementById(\"root\");\nReactDOM.render(<App />, rootElement);\n"],"sourceRoot":""}